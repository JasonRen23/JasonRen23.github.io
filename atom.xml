<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>JasonRen&#39;s Blog</title>
  
  <subtitle>Hello World!</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://jasonren.top/"/>
  <updated>2018-11-22T07:51:49.933Z</updated>
  <id>https://jasonren.top/</id>
  
  <author>
    <name>JasonRen</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>接口限流了解一下</title>
    <link href="https://jasonren.top/2018/09/08/%E6%8E%A5%E5%8F%A3%E9%99%90%E6%B5%81%E4%BA%86%E8%A7%A3%E4%B8%80%E4%B8%8B/"/>
    <id>https://jasonren.top/2018/09/08/接口限流了解一下/</id>
    <published>2018-09-07T16:00:00.000Z</published>
    <updated>2018-11-22T07:51:49.933Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>针对一个秒杀系统，可能会有百万级别的用户进行抢购，但实际的商品数量可能只有几百或者几十，远远小于用户数量。如果这些请求都进行入队操作或查询缓存，对于最终的结果没有任何的意义。因此，为了减少资源浪费，减轻后端压力，我们需要对秒杀进行<code>限流</code>，保障部分用户服务正常即可。</p><p>在开发高并发系统时，有三把利器用来保护系统：<code>缓存</code>、<code>降级</code>和<code>限流</code></p><p><code>缓存</code>：缓存的目的是提升系统访问速度和增大系统处理容量</p><p><code>降级</code>：降级是当服务器压力剧增的情况下，根据当前业务情况及流量对一些服务和页面有策略地进行降级，以此释放服务器资源以保证核心任务的正常运行。</p><p><code>限流</code>：限流的目的是通过对并发访问/请求进行限速，或者对一个时间窗口内的请求进行限速来保护系统，一旦达到限制速率则可以拒绝服务、排队</p><h2 id="限流方法"><a href="#限流方法" class="headerlink" title="限流方法"></a>限流方法</h2><p>限流可分为<code>单机限流</code>和<code>分布式限流</code>。</p><p>单机限流工具:</p><ul><li><code>AtomicInterger</code></li><li><code>RateLimiter</code></li><li><code>Semaphore</code></li></ul><p>分布式限流工具：</p><ul><li><code>Nginx + Lua</code></li><li><code>redis + Lua</code></li></ul><a id="more"></a><h2 id="单机限流算法"><a href="#单机限流算法" class="headerlink" title="单机限流算法"></a>单机限流算法</h2><h3 id="计数器"><a href="#计数器" class="headerlink" title="计数器"></a>计数器</h3><p>介绍：在接口层面应用比较广泛，即在一段时间内，进行计数，与阈值进行比较，到了时间临界点，将计数器清0。</p><p><img src="https://ws1.sinaimg.cn/large/73d640f7ly1fv2fp0nzq9j20gi05imx0.jpg" alt=""></p><p>不足：存在时间临界点的问题，在某个时间临界点会承受恶意用户的大量请求，甚至超出系统预期的承受。</p><p><img src="https://ws1.sinaimg.cn/large/73d640f7ly1fv2fotk8k9j20mk0c23z2.jpg" alt=""></p><p>由上图可见，恶意用户可能在0:59时瞬间发送100个请求，在1:00又瞬间发送100个请求，这样一来用户在一秒内就发送了200个请求，极有可能通过这个算法漏洞瞬间压垮我们的应用。</p><h2 id="滑动窗口"><a href="#滑动窗口" class="headerlink" title="滑动窗口"></a>滑动窗口</h2><p>这里的滑动窗口类似于TCP中的滑动窗口，如果我们把刚刚一分钟看做一个窗口的话，现在我们划分为6格，每格代表10秒钟，比如我们有个请求在0:35秒的时候到来，那么0:30-0:39对应的counter就会加1。</p><p><img src="https://ws1.sinaimg.cn/large/73d640f7ly1fv2foisdc8j20y80eodfz.jpg" alt=""></p><p>接下来我们看看滑动窗口如何解决计数器的临界问题，0:59到达的100个请求落在灰色的格子里，而1:00到达的100个请求会落在橘黄色的格子里。当时间到达1:00时，我们的时间窗口（虚线表示）会往右移动一格，此时时间窗口内的总请求数量为200个，超过了限定的100个，能够检测出触发限流的条件。</p><p>可见，当滑动窗口的格子划分越多，那么滑动窗口的滚动就越平滑，限流的统计就会更精细。</p><h2 id="漏桶算法"><a href="#漏桶算法" class="headerlink" title="漏桶算法"></a>漏桶算法</h2><p>与上述两种算法不同，漏桶算法脱离了时间片的概念，限流统计的方法更为先进。</p><p><img src="https://ws1.sinaimg.cn/large/73d640f7ly1fv2fxjyxtzj20cb08b74u.jpg" alt=""></p><p>在漏洞中没有水时：</p><ul><li>如果进水速率小于等于最大出水速率，那么出水速率等于进水速率，此时不会积水</li><li>如果进水速率大于最大出水速率，那么漏斗以最大速率出水，此时多余的水会积在漏斗中</li></ul><p>在漏洞中有水时：</p><ul><li>出水口以最大速率出水</li><li>如果漏斗未满，且有进水的话，那么这些水会积在漏斗中</li><li>如果漏斗已满，且有进水的话，那么这些水会溢出到漏斗之外</li></ul><p>由上可见，漏桶算法可以限制网络传输的速率，但无法处理突发传输，比如接口请求量在某一时刻突然激增到了十多倍，如果应用接口毫无限制地处理请求返回数据包，很有可能造成整个应用的不可用。</p><p>示例代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LeakyBucketDemo</span> </span>&#123;</span><br><span class="line">    <span class="comment">//时间刻度</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">long</span> time = System.currentTimeMillis();</span><br><span class="line">    <span class="comment">//桶里面现在的水</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> water = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//桶的大小</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> size = <span class="number">10</span>;</span><br><span class="line">    <span class="comment">//出水速率</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> rate = <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">grant</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//计算出水的数量</span></span><br><span class="line">        <span class="keyword">long</span> now = System.currentTimeMillis();</span><br><span class="line">        <span class="keyword">int</span> out = (<span class="keyword">int</span>) ((now - time) / <span class="number">700</span> * rate);</span><br><span class="line">        <span class="comment">//漏水后的剩余</span></span><br><span class="line">        water = Math.max(<span class="number">0</span>, water - out);</span><br><span class="line">        time = now;</span><br><span class="line">        <span class="keyword">if</span> ((water + <span class="number">1</span>) &lt; size) &#123;</span><br><span class="line">            ++water;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">500</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    <span class="keyword">if</span> (grant()) &#123;</span><br><span class="line">                        System.out.println(<span class="string">"执行业务逻辑"</span>);</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        System.out.println(<span class="string">"限流"</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="令牌桶算法"><a href="#令牌桶算法" class="headerlink" title="令牌桶算法"></a>令牌桶算法</h2><p>为解决瞬时大容量导致大部分网络请求被丢弃的情况，使用令牌桶进行了算法改进。</p><p>令牌桶算法是一个存放固定容量令牌（token）的桶，按照固定速率往桶里添加令牌。</p><ul><li>令牌按固定的速率被放入令牌桶中，如：r tokens/s</li><li>桶中最多存放b个令牌，当桶满时，新添加的令牌被丢弃或拒绝</li><li>当一个n字节大小的数据包到达，将从桶里删除n个令牌，接着数据包被发送到网络上</li><li>如果桶中的令牌不足n个，则不会删除令牌，且数据包将被限流（丢弃或在缓冲区等待）</li></ul><p><img src="https://ws1.sinaimg.cn/large/73d640f7ly1fv2iy42vkkj20g909l0v3.jpg" alt=""></p><h2 id="Google-Guava-RateLimiter"><a href="#Google-Guava-RateLimiter" class="headerlink" title="Google Guava RateLimiter"></a>Google Guava RateLimiter</h2><p>Guava包的通常用途，详见<a href="https://cloud.tencent.com/developer/news/237548" target="_blank" rel="noopener">此链接</a>：</p><ul><li>对JDK集合的补充和改进</li><li>提供本地缓存Guava Cache</li><li>对JDK提供的线程池进行异步回调</li><li>提供RateLimter限流工具类</li></ul><p>pom依赖如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.google.guava<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>guava<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>18.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>示例代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RateLimiterDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ListeningExecutorService executorService = MoreExecutors.listeningDecorator(Executors.newFixedThreadPool(<span class="number">100</span>));</span><br><span class="line">        <span class="comment">//指定每秒释放一个令牌</span></span><br><span class="line">        RateLimiter rateLimiter = RateLimiter.create(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">50</span>; i++) &#123;</span><br><span class="line">            <span class="comment">//请求RateLimiter,超过permits会被阻塞</span></span><br><span class="line">            <span class="comment">//acquire(int permits)函数主要用于获取permits个令牌，并计算需要等待多长时间，进而挂起等待，并将该值返回</span></span><br><span class="line">            Double acquire = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">if</span> (i == <span class="number">1</span>) &#123;</span><br><span class="line">                acquire = rateLimiter.acquire(<span class="number">1</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (i == <span class="number">2</span>) &#123;</span><br><span class="line">                acquire = rateLimiter.acquire(<span class="number">10</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (i == <span class="number">3</span>) &#123;</span><br><span class="line">                acquire = rateLimiter.acquire(<span class="number">2</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (i == <span class="number">4</span>) &#123;</span><br><span class="line">                acquire = rateLimiter.acquire(<span class="number">20</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                acquire = rateLimiter.acquire(<span class="number">2</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            executorService.submit(<span class="keyword">new</span> Task(<span class="string">"获取令牌成功，获取耗时："</span> + acquire + <span class="string">" 第 "</span> + i + <span class="string">" 个任务执行"</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Task</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    String str;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Task</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.str = str;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        SimpleDateFormat simpleDateFormat = <span class="keyword">new</span> SimpleDateFormat(<span class="string">"yyyy-MM-dd HH:mm:ss.SSS"</span>);</span><br><span class="line">        System.out.println(simpleDateFormat.format(<span class="keyword">new</span> Date()) + <span class="string">" | "</span> + Thread.currentThread().getName() + str);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><p><img src="https://ws1.sinaimg.cn/large/73d640f7ly1fv2jlcsoitj21cs0dkgtx.jpg" alt=""></p><p><code>create(double permitsPerSecond)</code>函数用于根据指定的稳定吞吐率创建RateLimiter，这里的吞吐率是指每秒多少许可数（通常是指QPS，每秒多少查询）</p><p><code>acquire(int permits)</code>函数从RateLimiter获取指定许可数，该方法会被阻塞直到获取到请求</p><p>由结果可以看出上一次请求获取的permit数越多，那么下一次再次获取授权时等待的时间会更长，反之，如果上一次获取的少，那么时间向后推移的就少，下一次获取许可的时间更短。</p><h2 id="令牌桶和漏桶的比较"><a href="#令牌桶和漏桶的比较" class="headerlink" title="令牌桶和漏桶的比较"></a>令牌桶和漏桶的比较</h2><table><thead><tr><th>区别</th><th>令牌桶</th><th>漏桶</th></tr></thead><tbody><tr><td>请求何时拒绝</td><td>固定速率往桶中添加令牌，如果桶中令牌不够，则拒绝新请求</td><td>流入请求速率任意，常量固定速率流出请求。当流入请求数积累到漏桶容量时，则拒绝新请求</td></tr><tr><td>速率限制</td><td>限制平均流入速率，允许一定程度的突发请求（支持一次拿多个令牌）</td><td>限制常量流出速率（流出速率是固定值），从而平滑突发流入速率</td></tr></tbody></table><h2 id="更多"><a href="#更多" class="headerlink" title="更多"></a>更多</h2><p><a href="http://ifeve.com/guava-ratelimiter/" target="_blank" rel="noopener">Guava官方文档-RateLimiter类</a></p><p>源码解析可参考：</p><ul><li><a href="https://mp.weixin.qq.com/s?__biz=MzI1MTU3ODk3OQ==&amp;mid=2247483743&amp;idx=1&amp;sn=fb278227775687c703621c4490de9940&amp;chksm=e9f19e53de8617456331a63a4895ce6c8faa5e51e76e99e7ca0d74ac3afde0e41002722e5e8c&amp;scene=21#wechat_redirect" target="_blank" rel="noopener">Guava令牌桶算法实现源码分析（一）</a></li><li><a href="https://mp.weixin.qq.com/s?__biz=MzI1MTU3ODk3OQ==&amp;mid=2247483762&amp;idx=1&amp;sn=cd1f31d3e924a2cab63fc48c5e7cbbdd&amp;chksm=e9f19e7ede86176863c38de3d2ec3ac9648fe7c6b67f23176428792589677f97bb13507ceb8c&amp;scene=21#wechat_redirect" target="_blank" rel="noopener">Guava令牌桶算法实现源码分析（二）</a></li><li><a href="https://mp.weixin.qq.com/s/GOBmSOvWqpmLp2rijZ6q4w" target="_blank" rel="noopener">Guava令牌桶算法实现源码分析（三）</a></li></ul><p><a href="https://github.com/zq2599/blog_demos/tree/master/guavalimitdemo" target="_blank" rel="noopener">Spring MVC限流实战</a></p><p><a href="https://juejin.im/post/5b7625e051882533122e1fc4" target="_blank" rel="noopener">分布式限流Redis+Lua实现</a></p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ol><li><a href="https://mp.weixin.qq.com/s?__biz=MzA3MTUzOTcxOQ==&amp;mid=2452964796&amp;idx=1&amp;sn=281842ac2a970d67b3946c85196b6cf4&amp;chksm=88ede8d4bf9a61c2b1a5a19759098f88e56d6d0958667af90cc99fec863bb47e4cf4d26366ea&amp;token=633981981&amp;lang=zh_CN#rd" target="_blank" rel="noopener">接口限流算法：漏桶算法&amp;令牌桶算法</a></li><li><a href="http://www.dongyeo.com/2015/11/15/guava-rate-limiter/" target="_blank" rel="noopener">Guava RateLimiter 接口限流</a></li><li><a href="https://blog.csdn.net/jek123456/article/details/77152571" target="_blank" rel="noopener">对高并发流量控制的一点思考</a></li><li><a href="https://juejin.im/entry/57cce5d379bc440063066d09" target="_blank" rel="noopener">接口限流算法总结</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;针对一个秒杀系统，可能会有百万级别的用户进行抢购，但实际的商品数量可能只有几百或者几十，远远小于用户数量。如果这些请求都进行入队操作或查询缓存，对于最终的结果没有任何的意义。因此，为了减少资源浪费，减轻后端压力，我们需要对秒杀进行&lt;code&gt;限流&lt;/code&gt;，保障部分用户服务正常即可。&lt;/p&gt;&lt;p&gt;在开发高并发系统时，有三把利器用来保护系统：&lt;code&gt;缓存&lt;/code&gt;、&lt;code&gt;降级&lt;/code&gt;和&lt;code&gt;限流&lt;/code&gt;&lt;/p&gt;&lt;p&gt;&lt;code&gt;缓存&lt;/code&gt;：缓存的目的是提升系统访问速度和增大系统处理容量&lt;/p&gt;&lt;p&gt;&lt;code&gt;降级&lt;/code&gt;：降级是当服务器压力剧增的情况下，根据当前业务情况及流量对一些服务和页面有策略地进行降级，以此释放服务器资源以保证核心任务的正常运行。&lt;/p&gt;&lt;p&gt;&lt;code&gt;限流&lt;/code&gt;：限流的目的是通过对并发访问/请求进行限速，或者对一个时间窗口内的请求进行限速来保护系统，一旦达到限制速率则可以拒绝服务、排队&lt;/p&gt;&lt;h2 id=&quot;限流方法&quot;&gt;&lt;a href=&quot;#限流方法&quot; class=&quot;headerlink&quot; title=&quot;限流方法&quot;&gt;&lt;/a&gt;限流方法&lt;/h2&gt;&lt;p&gt;限流可分为&lt;code&gt;单机限流&lt;/code&gt;和&lt;code&gt;分布式限流&lt;/code&gt;。&lt;/p&gt;&lt;p&gt;单机限流工具:&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;code&gt;AtomicInterger&lt;/code&gt;&lt;/li&gt;&lt;li&gt;&lt;code&gt;RateLimiter&lt;/code&gt;&lt;/li&gt;&lt;li&gt;&lt;code&gt;Semaphore&lt;/code&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;分布式限流工具：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;code&gt;Nginx + Lua&lt;/code&gt;&lt;/li&gt;&lt;li&gt;&lt;code&gt;redis + Lua&lt;/code&gt;&lt;/li&gt;&lt;/ul&gt;
    
    </summary>
    
      <category term="Java" scheme="https://jasonren.top/categories/Java/"/>
    
    
      <category term="并发" scheme="https://jasonren.top/tags/%E5%B9%B6%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>Java反编译工具箱</title>
    <link href="https://jasonren.top/2018/08/28/java%E5%8F%8D%E7%BC%96%E8%AF%91%E4%B9%8B%E8%B7%AF/"/>
    <id>https://jasonren.top/2018/08/28/java反编译之路/</id>
    <published>2018-08-27T16:00:00.000Z</published>
    <updated>2018-11-22T07:51:49.931Z</updated>
    
    <content type="html"><![CDATA[<p>之前<a href="https://jasonren.top/2018/08/02/Java%E4%B8%AD%E7%9A%84%E8%AF%AD%E6%B3%95%E7%B3%96/">java中的语法糖</a>一文使用过jd-gui来完成我们的反编译，它和<code>javap</code>的反编译不同，<code>javap</code>不是生成java文件，而是生成字节码。</p><h2 id="编译和反编译的基本概念"><a href="#编译和反编译的基本概念" class="headerlink" title="编译和反编译的基本概念"></a>编译和反编译的基本概念</h2><p>在正式介绍工具之前，还是得过一遍基础，介绍啰嗦一下编译和反编译。</p><p><strong>编译</strong>：将便于人编写、阅读、维护的高级计算机语言所写作的源代码程序，翻译为计算机能解读、运行的低阶机器语言的程序的过程就是编译。负责这一过程的处理的工具叫做编译器。编译给我们带来就是编出来的代码可读性更强，出了错也方便及时定位和修改。</p><p><strong>反编译</strong>:反编译的过程与编译刚好相反，就是将已编译好的编程语言还原到未编译的状态，也就是找出程序语言的源代码。就是将机器看得懂的语言转换成程序员可以看得懂的语言。Java语言中的反编译一般指将class文件转换成java文件。而反编译给我们带来的就是在使用各种语法糖带来的好处时，方便我们探究代码底层的原理。</p><a id="more"></a><h2 id="常用反编译工具的基本用法"><a href="#常用反编译工具的基本用法" class="headerlink" title="常用反编译工具的基本用法"></a>常用反编译工具的基本用法</h2><p><code>javap</code>的基本用法</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">javac HelloWorld.java //生成字节码class文件</span><br><span class="line">javap -c HelloWord.class / javap -verbose HelloWorld.class</span><br></pre></td></tr></table></figure><p><code>jd-gui</code>的基本用法</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">javac HelloWorld.java //生成字节码class文件</span><br><span class="line">jar cvf HelloWorld.jar HelloWorld.class //打成jar包</span><br></pre></td></tr></table></figure><p>然后通过<a href="https://github.com/java-decompiler/jd-gui/releases" target="_blank" rel="noopener">jd-gui</a>的gui导入查看反编译结果即可</p><h2 id="CFR（Class-File-Reader）反编译探索"><a href="#CFR（Class-File-Reader）反编译探索" class="headerlink" title="CFR（Class File Reader）反编译探索"></a>CFR（Class File Reader）反编译探索</h2><p>目前jd-gui在对Java7生成的字节码进行反编译时，偶尔会出现不支持的问题，比如java8 lamda表达式的一些语法。</p><p>下载<a href="http://www.benf.org/other/cfr/" target="_blank" rel="noopener">传送门</a></p><h3 id="switch语法糖"><a href="#switch语法糖" class="headerlink" title="switch语法糖"></a>switch语法糖</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">switchDemoString</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String str = <span class="string">"world"</span>;</span><br><span class="line">        <span class="keyword">switch</span> (str) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">"hello"</span>:</span><br><span class="line">                System.out.println(<span class="string">"hello"</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">"world"</span>:</span><br><span class="line">                System.out.println(<span class="string">"world"</span>);</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用cfr进行反编译</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">javac switchDemoString.java </span><br><span class="line">java -jar ~/cfr_0_132.jar switchDemoString.class --decodestringswitch <span class="literal">false</span> &gt; result.txt</span><br></pre></td></tr></table></figure><p>其中<code>decodestringswitch</code>表示对switch支持String的细节进行解码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">switchDemoString</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] arrstring)</span> </span>&#123;</span><br><span class="line">        String string;</span><br><span class="line">        String string2 = string = <span class="string">"world"</span>;</span><br><span class="line">        <span class="keyword">int</span> n = -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">switch</span> (string2.hashCode()) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">99162322</span>: &#123;</span><br><span class="line">                <span class="keyword">if</span> (!string2.equals(<span class="string">"hello"</span>)) <span class="keyword">break</span>;</span><br><span class="line">                n = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">113318802</span>: &#123;</span><br><span class="line">                <span class="keyword">if</span> (!string2.equals(<span class="string">"world"</span>)) <span class="keyword">break</span>;</span><br><span class="line">                n = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">switch</span> (n) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">0</span>: &#123;</span><br><span class="line">                System.out.println(<span class="string">"hello"</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">1</span>: &#123;</span><br><span class="line">                System.out.println(<span class="string">"world"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到switch底层是使用了<code>hashCode()</code>和<code>equals()</code>来判断字符串是否相等。</p><h3 id="lamda语法糖"><a href="#lamda语法糖" class="headerlink" title="lamda语法糖"></a>lamda语法糖</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LamdaTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; list = Arrays.asList(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>);</span><br><span class="line">        list.forEach(n -&gt; System.out.println(n));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们使用参数<code></code>查看lambda脱糖后的效果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Decompiled with CFR 0_132.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LamdaTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] arrstring)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; list = Arrays.asList(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>);</span><br><span class="line">        list.forEach((Consumer&lt;Integer&gt;)LambdaMetafactory.metafactory(<span class="keyword">null</span>, <span class="keyword">null</span>, <span class="keyword">null</span>, (Ljava/lang/Object;)V, lambda$main$<span class="number">0</span>(java.lang.Integer ), (Ljava/lang/Integer;)V)());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="comment">/* synthetic */</span> <span class="keyword">void</span> lambda$main$<span class="number">0</span>(Integer n) &#123;</span><br><span class="line">        System.out.println(n);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>lambdaMetafactory（如上所述）采用MethodHandles和MethodTypes，它们不能很好地表示，前三个参数由JVM填充，因此我将它们视为null，可以看到底层实际重新封装了一个打印函数对list内的元素遍历打印。</p><h3 id="try-with-resources"><a href="#try-with-resources" class="headerlink" title="try-with-resources"></a>try-with-resources</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">tryresourcesDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testEnhancedTryEmpty</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> (<span class="keyword">final</span> StringWriter writer = <span class="keyword">new</span> StringWriter();</span><br><span class="line">             <span class="keyword">final</span> StringWriter writer2 = <span class="keyword">new</span> StringWriter()) &#123;</span><br><span class="line">            writer.write(<span class="string">"This is only a test 2."</span>);</span><br><span class="line">            writer2.write(<span class="string">"Also"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Decompiled with CFR 0_132.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">tryresourcesDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testEnhancedTryEmpty</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        StringWriter stringWriter = <span class="keyword">new</span> StringWriter();</span><br><span class="line">        Throwable throwable = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            StringWriter stringWriter2 = <span class="keyword">new</span> StringWriter();</span><br><span class="line">            Throwable throwable2 = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                stringWriter.write(<span class="string">"This is only a test 2."</span>);</span><br><span class="line">                stringWriter2.write(<span class="string">"Also"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">catch</span> (Throwable throwable3) &#123;</span><br><span class="line">                throwable2 = throwable3;</span><br><span class="line">                <span class="keyword">throw</span> throwable3;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">finally</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (stringWriter2 != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (throwable2 != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            stringWriter2.close();</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">catch</span> (Throwable throwable4) &#123;</span><br><span class="line">                            throwable2.addSuppressed(throwable4);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        stringWriter2.close();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (Throwable throwable5) &#123;</span><br><span class="line">            throwable = throwable5;</span><br><span class="line">            <span class="keyword">throw</span> throwable5;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (stringWriter != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (throwable != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        stringWriter.close();</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">catch</span> (Throwable throwable6) &#123;</span><br><span class="line">                        throwable.addSuppressed(throwable6);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    stringWriter.close();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到反编译之后产生了大量的代码，包括异常类的定义和关闭资源的操作，这也是代码脱糖后的结果，这里同样需要加上参数<code>--tryresources false</code>。</p><p>更多的关于java8和java9反编译的区别可以进<a href="http://www.benf.org/other/cfr/java9observations.html" target="_blank" rel="noopener">这里</a>。</p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ol><li><a href="https://mp.weixin.qq.com/s?__biz=MzI3NzE0NjcwMg==&amp;mid=2650120609&amp;idx=1&amp;sn=5659f96310963ad57d55b48cee63c788&amp;chksm=f36bbc80c41c3596a1e4bf9501c6280481f1b9e06d07af354474e6f3ed366fef016df673a7ba&amp;scene=21#wechat_redirect" target="_blank" rel="noopener">Java开发必会的反编译知识</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;之前&lt;a href=&quot;https://jasonren.top/2018/08/02/Java%E4%B8%AD%E7%9A%84%E8%AF%AD%E6%B3%95%E7%B3%96/&quot;&gt;java中的语法糖&lt;/a&gt;一文使用过jd-gui来完成我们的反编译，它和&lt;code&gt;javap&lt;/code&gt;的反编译不同，&lt;code&gt;javap&lt;/code&gt;不是生成java文件，而是生成字节码。&lt;/p&gt;&lt;h2 id=&quot;编译和反编译的基本概念&quot;&gt;&lt;a href=&quot;#编译和反编译的基本概念&quot; class=&quot;headerlink&quot; title=&quot;编译和反编译的基本概念&quot;&gt;&lt;/a&gt;编译和反编译的基本概念&lt;/h2&gt;&lt;p&gt;在正式介绍工具之前，还是得过一遍基础，介绍啰嗦一下编译和反编译。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;编译&lt;/strong&gt;：将便于人编写、阅读、维护的高级计算机语言所写作的源代码程序，翻译为计算机能解读、运行的低阶机器语言的程序的过程就是编译。负责这一过程的处理的工具叫做编译器。编译给我们带来就是编出来的代码可读性更强，出了错也方便及时定位和修改。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;反编译&lt;/strong&gt;:反编译的过程与编译刚好相反，就是将已编译好的编程语言还原到未编译的状态，也就是找出程序语言的源代码。就是将机器看得懂的语言转换成程序员可以看得懂的语言。Java语言中的反编译一般指将class文件转换成java文件。而反编译给我们带来的就是在使用各种语法糖带来的好处时，方便我们探究代码底层的原理。&lt;/p&gt;
    
    </summary>
    
      <category term="Java" scheme="https://jasonren.top/categories/Java/"/>
    
    
      <category term="JVM" scheme="https://jasonren.top/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>redis-cluster踩坑指南</title>
    <link href="https://jasonren.top/2018/08/20/redis-cluster/"/>
    <id>https://jasonren.top/2018/08/20/redis-cluster/</id>
    <published>2018-08-19T16:00:00.000Z</published>
    <updated>2018-11-22T07:51:49.932Z</updated>
    
    <content type="html"><![CDATA[<h2 id="版本"><a href="#版本" class="headerlink" title="版本"></a>版本</h2><blockquote><p>redis 4.0.11<br>ruby 2.0.0</p></blockquote><p><img src="https://blog.octo.com/wp-content/uploads/2017/08/screen-shot-2017-08-11-at-14-34-48.png" width="40%" height="40%" style="display:block;margin:auto"></p><a id="more"></a><h2 id="创建目录和配置"><a href="#创建目录和配置" class="headerlink" title="创建目录和配置"></a>创建目录和配置</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> ~</span><br><span class="line">mkdir redisCluster</span><br><span class="line"><span class="built_in">cd</span> redisCluster</span><br><span class="line">mkdir 7000 7001 7002 7003 7004 7005</span><br></pre></td></tr></table></figure><p>然后将&lt;你的redis安装目录&gt;/redis.conf拷贝到这六个文件夹，并将redis.conf文件的内容改为如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 端口号，每个目录都不同</span></span><br><span class="line">port 700X</span><br><span class="line"><span class="comment"># 开启集群模式</span></span><br><span class="line">cluster-enabled yes</span><br><span class="line"><span class="comment">#节点超时实际，单位毫秒</span></span><br><span class="line">cluster-node-timeout 5000</span><br><span class="line"><span class="comment">#集群内部配置文件(默认为 nodes.conf)</span></span><br><span class="line">cluster-config-file nodes.conf</span><br><span class="line"><span class="comment"># 启动 AOF</span></span><br><span class="line">appendonly yes</span><br></pre></td></tr></table></figure><p>按照上述配置修改端口号之后，在每个目录下执行命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-server redis.conf</span><br></pre></td></tr></table></figure><p>起一个redis服务然后再中断后，会产生如下文件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">➜  7000 ls</span><br><span class="line">appendonly.aof  dump.rdb  nodes.conf  redis.conf</span><br></pre></td></tr></table></figure><p>可使用脚本后台启动六个节点服务</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> $(seq 0 5)</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">    <span class="built_in">cd</span> 700<span class="variable">$&#123;i&#125;</span></span><br><span class="line">    redis-server redis.conf &amp;</span><br><span class="line">    <span class="built_in">cd</span> ..</span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure><p>检验一下启动情况：</p><p><img src="https://ws1.sinaimg.cn/large/73d640f7ly1fufjlr24d2j20rc04zdhb.jpg" alt=""></p><p>Redis提供了redis-trib.rb这个ruby脚本来帮助我们构建cluster，下面我们就使用它</p><h2 id="安装gem-redis-ruby的redis接口"><a href="#安装gem-redis-ruby的redis接口" class="headerlink" title="安装gem-redis (ruby的redis接口)"></a>安装gem-redis (ruby的redis接口)</h2><p>若直接使用<code>gem install redis</code>，会出现redis版本过高，或者如下下载源连接不上的情况：</p><p><img src="https://ws1.sinaimg.cn/large/73d640f7ly1fufjumhiuxj20sa03e74z.jpg" alt=""></p><p>可使用如下命令安装:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo gem install redis </span><br><span class="line">--version 3.0.0 </span><br><span class="line">--<span class="built_in">source</span> http://rubygems.org</span><br></pre></td></tr></table></figure><p>注意指定下载源和下载的gem-redis版本</p><h2 id="解决哈希slot被占用的问题"><a href="#解决哈希slot被占用的问题" class="headerlink" title="解决哈希slot被占用的问题"></a>解决哈希slot被占用的问题</h2><p>准备条件就绪了之后，可直接使用如下命令构建集群：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># --replicas 则指定了为Redis Cluster中的每个Master节点配备几个Slave节点  </span></span><br><span class="line"><span class="comment"># 节点角色由顺序决定,先master之后是slave</span></span><br><span class="line">ruby redis-trib.rb create --replicas 1 </span><br><span class="line">127.0.0.1:7000 </span><br><span class="line">127.0.0.1:7001 </span><br><span class="line">127.0.0.1:7002 </span><br><span class="line">127.0.0.1:7003 </span><br><span class="line">127.0.0.1:7004 </span><br><span class="line">127.0.0.1:7005</span><br></pre></td></tr></table></figure><p>但是会报如下错误：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ERR Slot 0 is already busy (Redis::CommandError)</span><br></pre></td></tr></table></figure><p>解决方法：</p><p>可进入每个节点的client，然后先后执行<code>flushall</code>和<code>cluster reset soft</code></p><h2 id="构建集群并测试"><a href="#构建集群并测试" class="headerlink" title="构建集群并测试"></a>构建集群并测试</h2><p>再次执行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ruby redis-trib.rb create --replicas 1 </span><br><span class="line">127.0.0.1:7000 </span><br><span class="line">127.0.0.1:7001 </span><br><span class="line">127.0.0.1:7002 </span><br><span class="line">127.0.0.1:7003 </span><br><span class="line">127.0.0.1:7004 </span><br><span class="line">127.0.0.1:7005</span><br></pre></td></tr></table></figure><p>master-slave的关系按照顺序分配：</p><p><img src="https://ws1.sinaimg.cn/large/73d640f7ly1fufkb95092j20jv0fu77o.jpg" alt=""></p><p>总共16384个slot也全部分配好了：</p><p><img src="https://ws1.sinaimg.cn/large/73d640f7ly1fufkceqaiaj20jz0g2n0k.jpg" alt=""></p><p>这下我们可以测试一下主从之间的数据一致性：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">➜  src redis-cli -c -p 7000</span><br><span class="line"></span><br><span class="line">127.0.0.1:7000&gt; <span class="built_in">set</span> myname jason</span><br><span class="line">-&gt; Redirected to slot [12807] located at 127.0.0.1:7002</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:7002&gt; get myname</span><br><span class="line"><span class="string">"jason"</span></span><br></pre></td></tr></table></figure><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ol><li><a href="http://thinkinjava.cn/2018/08/Mac-%E6%90%AD%E5%BB%BA-Redis-%E9%9B%86%E7%BE%A4/" target="_blank" rel="noopener">Mac搭建redis集群</a></li><li><a href="http://hot66hot.iteye.com/blog/2050676?page=2" target="_blank" rel="noopener">redis-cluster的研究和使用</a></li><li><a href="https://blog.csdn.net/yangbo19891/article/details/73200740" target="_blank" rel="noopener">mac环境下redis集群的搭建</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;版本&quot;&gt;&lt;a href=&quot;#版本&quot; class=&quot;headerlink&quot; title=&quot;版本&quot;&gt;&lt;/a&gt;版本&lt;/h2&gt;&lt;blockquote&gt;&lt;p&gt;redis 4.0.11&lt;br&gt;ruby 2.0.0&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;img src=&quot;https://blog.octo.com/wp-content/uploads/2017/08/screen-shot-2017-08-11-at-14-34-48.png&quot; width=&quot;40%&quot; height=&quot;40%&quot; style=&quot;display:block;margin:auto&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="数据库" scheme="https://jasonren.top/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
      <category term="redis" scheme="https://jasonren.top/tags/redis/"/>
    
  </entry>
  
  <entry>
    <title>kafka学习(1)-producer和consumer的简单demo</title>
    <link href="https://jasonren.top/2018/08/19/kafka-demo1/"/>
    <id>https://jasonren.top/2018/08/19/kafka-demo1/</id>
    <published>2018-08-18T16:00:00.000Z</published>
    <updated>2018-11-22T07:51:49.932Z</updated>
    
    <content type="html"><![CDATA[<h2 id="版本"><a href="#版本" class="headerlink" title="版本"></a>版本</h2><blockquote><p>操作系统：OS X 10.10.3</p><p>JDK版本： 1.8</p><p>zookeeper版本：zookeeper-3.5.9</p><p>kafka版本：1.0.0</p></blockquote><h2 id="包依赖"><a href="#包依赖" class="headerlink" title="包依赖"></a>包依赖</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.kafka<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>kafka-clients<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.11.0.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="启动zookeeper和kafka"><a href="#启动zookeeper和kafka" class="headerlink" title="启动zookeeper和kafka"></a>启动zookeeper和kafka</h2><p>zookeeper</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./bin/zkServer.sh start</span><br></pre></td></tr></table></figure><p>kafka</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sh bin/kafka-server-start.sh  </span><br><span class="line">config/server.properties &amp;</span><br></pre></td></tr></table></figure><a id="more"></a><h2 id="在kafka新建一个主题"><a href="#在kafka新建一个主题" class="headerlink" title="在kafka新建一个主题"></a>在kafka新建一个主题</h2><p><img src="https://images2015.cnblogs.com/blog/735367/201612/735367-20161226175429711-638862783.png" alt=""></p><p>新建了一个名为<code>first_topic</code>的主题</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">sh bin/kafka-topics.sh --create </span><br><span class="line">--zookeeper localhost:2181 </span><br><span class="line">--replication-factor 1 </span><br><span class="line">--partitions 1 </span><br><span class="line">--topic first_topic</span><br></pre></td></tr></table></figure><p>查看已经建立的主题</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sh bin/kafka-topics.sh --list </span><br><span class="line">--zookeeper localhost:2181</span><br></pre></td></tr></table></figure><h2 id="生产者Java代码"><a href="#生产者Java代码" class="headerlink" title="生产者Java代码"></a>生产者Java代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.apache.kafka.clients.producer.KafkaProducer;</span><br><span class="line"><span class="keyword">import</span> org.apache.kafka.clients.producer.ProducerRecord;</span><br><span class="line"><span class="keyword">import</span> org.apache.kafka.common.serialization.StringSerializer;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Properties;</span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> JasonRen</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 2018/8/9 上午11:22</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Producer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//配置属性</span></span><br><span class="line">        Properties properties = <span class="keyword">new</span> Properties();</span><br><span class="line">        properties.put(<span class="string">"bootstrap.servers"</span>, <span class="string">"localhost:9092"</span>);</span><br><span class="line">        <span class="comment">//指定序列化器</span></span><br><span class="line">        properties.put(<span class="string">"key.serializer"</span>, StringSerializer.class.getName());</span><br><span class="line">        properties.put(<span class="string">"value.serializer"</span>, StringSerializer.class.getName());</span><br><span class="line"></span><br><span class="line">        <span class="comment">//生产者发送消息</span></span><br><span class="line">        String topic = <span class="string">"first_topic"</span>;</span><br><span class="line">        KafkaProducer&lt;String, String&gt; producer = <span class="keyword">new</span> KafkaProducer&lt;&gt;(properties);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">11</span>; i++) &#123;</span><br><span class="line">            Scanner scanner = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">            String value = scanner.nextLine();</span><br><span class="line"></span><br><span class="line">            ProducerRecord&lt;String, String&gt; msg = <span class="keyword">new</span> ProducerRecord&lt;&gt;(topic, value);</span><br><span class="line">            <span class="comment">//发送消息</span></span><br><span class="line">            producer.send(msg);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//保证缓存的消息能及时发送</span></span><br><span class="line">        producer.flush();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="消费者Java代码"><a href="#消费者Java代码" class="headerlink" title="消费者Java代码"></a>消费者Java代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.jasonren.kafka;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.kafka.clients.consumer.ConsumerRecord;</span><br><span class="line"><span class="keyword">import</span> org.apache.kafka.clients.consumer.ConsumerRecords;</span><br><span class="line"><span class="keyword">import</span> org.apache.kafka.clients.consumer.KafkaConsumer;</span><br><span class="line"><span class="keyword">import</span> org.slf4j.Logger;</span><br><span class="line"><span class="keyword">import</span> org.slf4j.LoggerFactory;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.Properties;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> JasonRen</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 2018/8/9 上午11:20</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Consumer</span> </span>&#123;</span><br><span class="line">    <span class="comment">/** logger */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger LOGGER = LoggerFactory.getLogger(Consumer.class);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//配置属性</span></span><br><span class="line">        Properties props = <span class="keyword">new</span> Properties();</span><br><span class="line">        props.put(<span class="string">"bootstrap.servers"</span>, <span class="string">"localhost:9092"</span>);</span><br><span class="line">        <span class="comment">//consumer组id</span></span><br><span class="line">        props.put(<span class="string">"group.id"</span>, <span class="string">"test"</span>);</span><br><span class="line">        <span class="comment">//自动调整offset到最新的offset</span></span><br><span class="line">        props.put(<span class="string">"auto.offset.reset"</span>, <span class="string">"earliest"</span>);</span><br><span class="line">        <span class="comment">//是否自动确认offset</span></span><br><span class="line">        props.put(<span class="string">"enable.auto.commit"</span>, <span class="string">"true"</span>);</span><br><span class="line">        <span class="comment">//指定反序列化器</span></span><br><span class="line">        props.put(<span class="string">"key.deserializer"</span>, StringDeserializer.class.getName());</span><br><span class="line">        props.put(<span class="string">"value.deserializer"</span>, StringDeserializer.class.getName());</span><br><span class="line"></span><br><span class="line">        KafkaConsumer&lt;String, String&gt; consumer = <span class="keyword">new</span> KafkaConsumer&lt;String, String&gt;(props);</span><br><span class="line">        <span class="comment">//指定订阅主题</span></span><br><span class="line">        consumer.subscribe(Arrays.asList(<span class="string">"first_topic"</span>));</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            ConsumerRecords&lt;String, String&gt; records = consumer.poll(<span class="number">100</span>);</span><br><span class="line">            <span class="keyword">for</span> (ConsumerRecord&lt;String, String&gt; record : records) &#123;</span><br><span class="line">                LOGGER.info(<span class="string">"offset = &#123;&#125;, key = &#123;&#125;, value = &#123;&#125;"</span>, record.offset(), record.key(), record.value());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为了更直观地看效果，我们可以把不需要打印的日志给关掉，直接在<code>log4j.properties</code>里关掉</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">log4j.logger.kafka.consumer.ZookeeperConsumerConnector=OFF</span><br><span class="line">log4j.logger.org.apache.kafka.clients.FetchSessionHandler=OFF</span><br><span class="line">log4j.logger.org.apache.kafka.clients.consumer.internals.Fetcher=OFF</span><br><span class="line">log4j.logger.org.springframework.kafka.listener.KafkaMessageListenerContainer=OFF</span><br><span class="line">log4j.logger.org.apache.kafka.clients.consumer.internals.AbstractCoordinator=OFF</span><br><span class="line">log4j.logger.org.apache.kafka.clients.consumer.internals.ConsumerCoordinator = OFF</span><br><span class="line">log4j.logger.org.apache.kafka.clients.NetworkClient = OFF</span><br><span class="line">log4j.logger.org.apache.kafka.common.metrics.Metrics= OFF</span><br><span class="line">log4l.logger.org.apache.kafka.clients.Metadata = OFF</span><br></pre></td></tr></table></figure><h2 id="消费者和生产者消息传递"><a href="#消费者和生产者消息传递" class="headerlink" title="消费者和生产者消息传递"></a>消费者和生产者消息传递</h2><p>生产者发送十条消息：</p><p><img src="https://ws1.sinaimg.cn/large/73d640f7ly1fuec8pbdw8j20d0090gn2.jpg" alt="Producer console log" width="40%" height="40%" style="display:block;margin:auto"></p><p>消费者消费消息，offset自增：</p><p><img src="https://ws1.sinaimg.cn/large/73d640f7ly1fuec6pam9wj21ee09cgq7.jpg" alt="Consumer console log"></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;版本&quot;&gt;&lt;a href=&quot;#版本&quot; class=&quot;headerlink&quot; title=&quot;版本&quot;&gt;&lt;/a&gt;版本&lt;/h2&gt;&lt;blockquote&gt;&lt;p&gt;操作系统：OS X 10.10.3&lt;/p&gt;&lt;p&gt;JDK版本： 1.8&lt;/p&gt;&lt;p&gt;zookeeper版本：zookeeper-3.5.9&lt;/p&gt;&lt;p&gt;kafka版本：1.0.0&lt;/p&gt;&lt;/blockquote&gt;&lt;h2 id=&quot;包依赖&quot;&gt;&lt;a href=&quot;#包依赖&quot; class=&quot;headerlink&quot; title=&quot;包依赖&quot;&gt;&lt;/a&gt;包依赖&lt;/h2&gt;&lt;figure class=&quot;highlight xml&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;dependency&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;groupId&lt;/span&gt;&amp;gt;&lt;/span&gt;org.apache.kafka&lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;name&quot;&gt;groupId&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;artifactId&lt;/span&gt;&amp;gt;&lt;/span&gt;kafka-clients&lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;name&quot;&gt;artifactId&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;version&lt;/span&gt;&amp;gt;&lt;/span&gt;0.11.0.1&lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;name&quot;&gt;version&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;name&quot;&gt;dependency&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;h2 id=&quot;启动zookeeper和kafka&quot;&gt;&lt;a href=&quot;#启动zookeeper和kafka&quot; class=&quot;headerlink&quot; title=&quot;启动zookeeper和kafka&quot;&gt;&lt;/a&gt;启动zookeeper和kafka&lt;/h2&gt;&lt;p&gt;zookeeper&lt;/p&gt;&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;./bin/zkServer.sh start&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;p&gt;kafka&lt;/p&gt;&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;sh bin/kafka-server-start.sh  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;config/server.properties &amp;amp;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="消息队列" scheme="https://jasonren.top/categories/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/"/>
    
    
      <category term="Kafka" scheme="https://jasonren.top/tags/Kafka/"/>
    
  </entry>
  
  <entry>
    <title>数据库连接池</title>
    <link href="https://jasonren.top/2018/08/10/%E6%95%B0%E6%8D%AE%E5%BA%93%E8%BF%9E%E6%8E%A5%E6%B1%A0/"/>
    <id>https://jasonren.top/2018/08/10/数据库连接池/</id>
    <published>2018-08-09T16:00:00.000Z</published>
    <updated>2018-11-22T07:51:49.933Z</updated>
    
    <content type="html"><![CDATA[<h2 id="什么情况使用连接池"><a href="#什么情况使用连接池" class="headerlink" title="什么情况使用连接池"></a>什么情况使用连接池</h2><p>对于一个简单的数据库应用，由于对于数据库的访问不是很频繁。这时可以简单地在需要访问数据库时，就新创建一个连接，用完后就关闭它，这样做也不会带来什么明显的性能上的开销。但是对于一个复杂的数据库应用，情况就完全不同了。频繁的建立、关闭连接，会极大的减低系统的性能，因为对于连接的使用成了系统性能的瓶颈。</p><h2 id="使用连接池的好处"><a href="#使用连接池的好处" class="headerlink" title="使用连接池的好处"></a>使用连接池的好处</h2><ol><li>连接复用。通过建立一个数据库连接池以及一套连接使用管理策略，使得一个数据库连接可以得到高效、安全的复用，避免了数据库连接频繁建立、关闭的开销。</li><li>对于共享资源，有一个很著名的设计模式：资源池。该模式正是为了解决资源频繁分配、释放所造成的问题的。把该模式应用到数据库连接管理领域，就是建立一个数据库连接池，提供一套高效的连接分配、使用策略，最终目标是实现连接的高效、安全的复用。</li></ol><a id="more"></a><h2 id="选型对比"><a href="#选型对比" class="headerlink" title="选型对比"></a>选型对比</h2><table><thead><tr><th>功能</th><th>C3P0</th><th>DBCP</th><th>Druid</th></tr></thead><tbody><tr><td>线程同步</td><td>单线程</td><td>单线程</td><td>多线程、异步</td></tr><tr><td>PSCache</td><td>是</td><td>是</td><td>是</td><td></td></tr><tr><td>LRU</td><td>否</td><td>是</td><td>是</td><td></td></tr><tr><td>ExceptionSorted</td><td>否</td><td>否</td><td>是</td><td></td></tr><tr><td>监控</td><td>jmx/log</td><td>jmx</td><td>jmx/log/http</td><td></td></tr><tr><td>扩展性</td><td>弱</td><td>弱</td><td>好</td><td></td></tr><tr><td>SQL拦截及解析</td><td>无</td><td>无</td><td>支持</td><td></td></tr><tr><td>代码复杂度</td><td>复杂</td><td>中等，超过60个类</td><td>复杂</td><td></td></tr><tr><td>特点</td><td>历史久远，代码逻辑复杂，且不易维护</td><td>依赖于apache-common-pool</td><td>阿里开源，功能全面，为监控而生</td><td></td></tr><tr><td>连接池管理</td><td>队列</td><td>LinkedBlockingDeque</td><td>数组/CopyOnWriteArrayList</td><td></td></tr><tr><td>Tomcat数据源、JNDI</td><td>数据源和JNDI绑定，支持JDBC2和JDBC3的扩展</td><td>支持JNDI配置，需要加入jconn3.jar</td><td>支持JDNI配置，com.alibaba.druid.pool.DruidDataSourceFactory</td><td></td></tr><tr><td>更新维护</td><td>2015.12.09</td><td>2015.8.6</td><td>更新维护</td><td></td></tr></tbody></table><table><thead><tr><th>功能</th><th>Tomcat-JDBC</th><th>BoneCP</th><th>HikariCP</th></tr></thead><tbody><tr><td>线程同步</td><td>多线程、异步</td><td>多线程、异步</td><td>多线程、异步</td></tr><tr><td>PSCache</td><td>是</td><td>是</td><td>否</td></tr><tr><td>LRU</td><td>是</td><td>否</td><td>否</td></tr><tr><td>ExceptionSorted</td><td>否</td><td>否</td><td>否</td></tr><tr><td>监控</td><td>jmx</td><td>jmx</td><td>jmx/metrics</td></tr><tr><td>扩展性</td><td>弱</td><td>好</td><td>好</td></tr><tr><td>SQL拦截及解析</td><td>无</td><td>无</td><td>无</td></tr><tr><td>代码复杂度</td><td>简单，8个核心类</td><td>简单</td><td>简单</td></tr><tr><td>特点</td><td>异步、高性能、DBCP连接池的备选方案</td><td>性能是C3P0的25倍左右</td><td>优化力度大，功能简单，起源于BoneCP</td></tr><tr><td>连接池管理</td><td>FairBlockingQueue</td><td>堆栈</td><td>threadlocal/CopyOnWriteArrayList</td></tr><tr><td>Tomcat数据源、JNDI</td><td>支持JDNI配置，Tomcat的一个模块</td><td>支持JNDI配置，com.jolbox.bonecp.BoneCPDataSource</td><td>支持JDNI配置，HikariJNDIFactory</td></tr><tr><td>更新维护</td><td>更新维护</td><td>2015.6.25</td><td>更新维护</td></tr></tbody></table><p>其中：</p><ul><li><code>PSCache</code>是数据库连接池的关键指标。在Oracle中，类似SELECT NAME FROM USER WHERE ID = ?这样的SQL，启用PSCache和不启用PSCache的性能可能是相差一个数量级的。Proxool是不支持PSCache的数据库连接池，如果你使用Oracle、SQL Server、DB2、Sybase这样支持游标的数据库，那你就完全不用考虑Proxool。</li><li><code>ExceptionSorter</code>是一个很重要的容错特性，如果一个连接产生了一个不可恢复的错误，必须立刻从连接池中去掉，否则会连续产生大量错误。这个特性，目前只有JBossDataSource和Druid实现。Druid的实现参考自JBossDataSource，经过长期生产反馈补充。</li></ul><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ol><li><a href="http://www.cnblogs.com/JavaSubin/p/5294721.html" target="_blank" rel="noopener">常用数据库连接池配置说明</a></li><li><a href="https://mp.weixin.qq.com/s/K4hNaPEfiw4dZiE7pw1Euw" target="_blank" rel="noopener">主流数据库连接池全面对比</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;什么情况使用连接池&quot;&gt;&lt;a href=&quot;#什么情况使用连接池&quot; class=&quot;headerlink&quot; title=&quot;什么情况使用连接池&quot;&gt;&lt;/a&gt;什么情况使用连接池&lt;/h2&gt;&lt;p&gt;对于一个简单的数据库应用，由于对于数据库的访问不是很频繁。这时可以简单地在需要访问数据库时，就新创建一个连接，用完后就关闭它，这样做也不会带来什么明显的性能上的开销。但是对于一个复杂的数据库应用，情况就完全不同了。频繁的建立、关闭连接，会极大的减低系统的性能，因为对于连接的使用成了系统性能的瓶颈。&lt;/p&gt;&lt;h2 id=&quot;使用连接池的好处&quot;&gt;&lt;a href=&quot;#使用连接池的好处&quot; class=&quot;headerlink&quot; title=&quot;使用连接池的好处&quot;&gt;&lt;/a&gt;使用连接池的好处&lt;/h2&gt;&lt;ol&gt;&lt;li&gt;连接复用。通过建立一个数据库连接池以及一套连接使用管理策略，使得一个数据库连接可以得到高效、安全的复用，避免了数据库连接频繁建立、关闭的开销。&lt;/li&gt;&lt;li&gt;对于共享资源，有一个很著名的设计模式：资源池。该模式正是为了解决资源频繁分配、释放所造成的问题的。把该模式应用到数据库连接管理领域，就是建立一个数据库连接池，提供一套高效的连接分配、使用策略，最终目标是实现连接的高效、安全的复用。&lt;/li&gt;&lt;/ol&gt;
    
    </summary>
    
      <category term="Java" scheme="https://jasonren.top/categories/Java/"/>
    
    
      <category term="连接池" scheme="https://jasonren.top/tags/%E8%BF%9E%E6%8E%A5%E6%B1%A0/"/>
    
  </entry>
  
  <entry>
    <title>Java中的语法糖</title>
    <link href="https://jasonren.top/2018/08/02/Java%E4%B8%AD%E7%9A%84%E8%AF%AD%E6%B3%95%E7%B3%96/"/>
    <id>https://jasonren.top/2018/08/02/Java中的语法糖/</id>
    <published>2018-08-01T16:00:00.000Z</published>
    <updated>2018-11-22T07:51:49.930Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>语法糖可以看做编译器实现的一些「小把戏」，这些「小把戏」用得好，可能会使得代码效率提升喔</p></blockquote><h2 id="自动装箱的陷阱"><a href="#自动装箱的陷阱" class="headerlink" title="自动装箱的陷阱"></a>自动装箱的陷阱</h2><p>先来看看《深入理解JVM虚拟机》的一道题：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">testInteger</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Integer a = <span class="number">1</span>;</span><br><span class="line">        Integer b = <span class="number">2</span>;</span><br><span class="line">        Integer c = <span class="number">3</span>;</span><br><span class="line">        Integer d = <span class="number">3</span>;</span><br><span class="line">        Integer e = <span class="number">321</span>;</span><br><span class="line">        Integer f = <span class="number">321</span>;</span><br><span class="line">        Long g = <span class="number">3L</span>;</span><br><span class="line">        Long h = <span class="number">3L</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        System.out.println(c == d);</span><br><span class="line">        System.out.println(e == f);</span><br><span class="line">        System.out.println(e.equals(f));</span><br><span class="line">        System.out.println(c == (a + b));</span><br><span class="line">        System.out.println(c.equals(a + b));</span><br><span class="line">        System.out.println(g == (a + b));</span><br><span class="line">        System.out.println(g.equals(a + b));</span><br><span class="line">        System.out.println(g.equals(a + h));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><a id="more"></a><p>输出：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">true</span></span><br><span class="line"><span class="keyword">false</span></span><br><span class="line"><span class="keyword">true</span></span><br><span class="line"><span class="keyword">true</span></span><br><span class="line"><span class="keyword">true</span></span><br><span class="line"><span class="keyword">true</span></span><br><span class="line"><span class="keyword">false</span></span><br><span class="line"><span class="keyword">true</span></span><br></pre></td></tr></table></figure><ul><li>首先<code>c == d</code>为true而<code>e == f</code>为false的原因是，Integer类有一个静态的内部类<strong>IntegerCache</strong>，专门用于缓存-128至127之间的值, 如果是则直接从缓存中返回对应的引用，否则新创建一个Integer的实例。所以说如果不在这个区间范围内，返回一个新创建的Long类型引用，用==判断就会理所当然的返回false，地址不一样。但是如果我们使用<strong>equals</strong>方法，则会返回true，数值是一样的。</li></ul><p><img src="https://ws1.sinaimg.cn/large/73d640f7ly1ftwv1vakgnj21dq09edjb.jpg" alt=""></p><ul><li>总结一下：</li><li>使用<code>==</code>的情况<ul><li>默认比较的是地址，如果使用了运算符，类似于（a+b），则比较的是数值</li><li>当比较地址时，若位于-127~128之间，则直接从缓存里返回已有的引用，也即值相等的话就相等，否则会生成一个Integer实例再进行比较。</li></ul></li><li>使用<code>equals()</code>的情况<ul><li>无论是哪种包装类中的equals()默认比较的是数值</li><li>需要注意的是，Long的equals()的实现逻辑先判断是不是Long的实例</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (obj <span class="keyword">instanceof</span> Long) &#123;</span><br><span class="line">            <span class="keyword">return</span> value == ((Long)obj).longValue();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>常使用<a href="https://github.com/java-decompiler/jd-gui/releases" target="_blank" rel="noopener">jd-gui</a>玩一把反编译</p><p>先打成jar包然后再用jd-gui反编译</p><ol><li>生成字节码类文件</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">javac -d &lt;dir&gt; *.java</span><br></pre></td></tr></table></figure><ol start="2"><li>将字节码类文件打成jar包</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jar cvf YourJar.jar *</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.PrintStream;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">testInteger</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] paramArrayOfString)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    Integer localInteger1 = Integer.valueOf(<span class="number">1</span>);</span><br><span class="line">    Integer localInteger2 = Integer.valueOf(<span class="number">2</span>);</span><br><span class="line">    Integer localInteger3 = Integer.valueOf(<span class="number">3</span>);</span><br><span class="line">    Integer localInteger4 = Integer.valueOf(<span class="number">3</span>);</span><br><span class="line">    Integer localInteger5 = Integer.valueOf(<span class="number">321</span>);</span><br><span class="line">    Integer localInteger6 = Integer.valueOf(<span class="number">321</span>);</span><br><span class="line">    Long localLong1 = Long.valueOf(<span class="number">3L</span>);</span><br><span class="line">    Long localLong2 = Long.valueOf(<span class="number">2L</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 在缓存池范围内，返回true</span></span><br><span class="line">    System.out.println(localInteger3 == localInteger4); </span><br><span class="line">    </span><br><span class="line">    <span class="comment">//不在范围内，返回false</span></span><br><span class="line">    System.out.println(localInteger5 == localInteger6);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//equals()比较的是包装类的数值，返回true</span></span><br><span class="line">    System.out.println(localInteger5.equals(localInteger6));</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//存在数值表达式，比较数值，返回true</span></span><br><span class="line">    System.out.println(localInteger3.intValue() == localInteger1.intValue() + localInteger2.intValue());</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//equals()，返回true</span></span><br><span class="line">    System.out.println(localInteger3.equals(Integer.valueOf(localInteger1.intValue() + localInteger2.intValue())));</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//存在数值表达式，返回true</span></span><br><span class="line">    System.out.println(localLong1.longValue() == localInteger1.intValue() + localInteger2.intValue());</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//Long的equals()先判断是不是Long的实例，返回false</span></span><br><span class="line">    System.out.println(localLong1.equals(Integer.valueOf(localInteger1.intValue() + localInteger2.intValue())));</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//数值相等且同为Long类型，返回true</span></span><br><span class="line">    System.out.println(localLong1.equals(Long.valueOf(localInteger1.intValue() + localLong2.longValue())));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="泛型擦除"><a href="#泛型擦除" class="headerlink" title="泛型擦除"></a>泛型擦除</h2><blockquote><p>泛型就是类型参数化，处理的数据类型不是固定的，而是可以作为参数传入，也即把类型明确的工作推迟到创建对象或调用方法的时候才去明确的特殊类型。</p></blockquote><p>参数化类型(Parametersized Type)：</p><ul><li>把类型当做是参数一样传递</li><li>&lt;数据类型&gt;只能是引用类型</li></ul><p><strong>泛型擦除</strong>：Java语言中的泛型与其他语言不大一样，它只在程序源码中存在，在编译后的字节码文件中，就已经替换为原来的原生类型（Raw Type，也成为裸类型）了，并且在相应的地方加入了强制转换代码。</p><h3 id="例子一"><a href="#例子一" class="headerlink" title="例子一"></a>例子一</h3><blockquote><p>字节码文件通过javap命令查看，如 javap -c demo1.class &gt; bytecode.txt</p></blockquote><p>字节码：<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// demo1.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">demo1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        List&lt;String&gt; stringList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        stringList.add(<span class="string">"jason"</span>);</span><br><span class="line">        stringList.add(<span class="string">"ren"</span>);</span><br><span class="line">        String str1 = stringList.get(<span class="number">0</span>);</span><br><span class="line">        stringList.get(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//demo1.class</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(java.lang.String[])</span></span>;</span><br><span class="line">    descriptor: ([Ljava/lang/String;)V</span><br><span class="line">    flags: ACC_PUBLIC, ACC_STATIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=<span class="number">2</span>, locals=<span class="number">3</span>, args_size=<span class="number">1</span></span><br><span class="line">         0: new           #2                  // class java/util/ArrayList</span><br><span class="line">         <span class="number">3</span>: dup</span><br><span class="line">         4: invokespecial #3                  // Method java/util/ArrayList."&lt;init&gt;":()V</span><br><span class="line">         <span class="number">7</span>: astore_1</span><br><span class="line">         <span class="number">8</span>: aload_1</span><br><span class="line">         9: ldc           #4                  // String jason</span><br><span class="line">        11: invokeinterface #5,  2            // InterfaceMethod java/util/List.add:(Ljava/lang/Object;)Z (add的是Object类型)</span><br><span class="line">        <span class="number">16</span>: pop</span><br><span class="line">        <span class="number">17</span>: aload_1</span><br><span class="line">        18: ldc           #6                  // String ren</span><br><span class="line">        20: invokeinterface #5,  2            // InterfaceMethod java/util/List.add:(Ljava/lang/Object;)Z (add的是Object类型)</span><br><span class="line">        <span class="number">25</span>: pop</span><br><span class="line">        <span class="number">26</span>: aload_1</span><br><span class="line">        <span class="number">27</span>: iconst_0</span><br><span class="line">        28: invokeinterface #7,  2            // InterfaceMethod java/util/List.get:(I)Ljava/lang/Object;</span><br><span class="line">        33: checkcast     #8                  // class java/lang/String(检查操作数栈顶的值的类型，get(0)然后进行了强转)</span><br><span class="line">        <span class="number">36</span>: astore_2</span><br><span class="line">        <span class="number">37</span>: aload_1</span><br><span class="line">        <span class="number">38</span>: iconst_1</span><br><span class="line">        39: invokeinterface #7,  2            // InterfaceMethod java/util/List.get:(I)Ljava/lang/Object;</span><br><span class="line">        <span class="number">44</span>: pop</span><br><span class="line">        <span class="number">45</span>: <span class="keyword">return</span></span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line <span class="number">13</span>: <span class="number">0</span></span><br><span class="line">        line <span class="number">14</span>: <span class="number">8</span></span><br><span class="line">        line <span class="number">15</span>: <span class="number">17</span></span><br><span class="line">        line <span class="number">16</span>: <span class="number">26</span></span><br><span class="line">        line <span class="number">17</span>: <span class="number">37</span></span><br><span class="line">        line <span class="number">18</span>: <span class="number">45</span></span><br></pre></td></tr></table></figure><p></p><p>反编译后的代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">demo1</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] paramArrayOfString)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    ArrayList localArrayList = <span class="keyword">new</span> ArrayList();</span><br><span class="line">    localArrayList.add(<span class="string">"jason"</span>);</span><br><span class="line">    localArrayList.add(<span class="string">"ren"</span>);</span><br><span class="line">    String str = (String)localArrayList.get(<span class="number">0</span>); <span class="comment">//强转</span></span><br><span class="line">    localArrayList.get(<span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>字节码可以看出两个问题：</p><ol><li>由字节码的11和20行可以看出，<code>locaArrayList.add()</code>方法接收的是Object类型，而不是指定的泛型String，说明泛型信息在编译后不存在了</li><li>由字节码的33行和反编译可以看出，<code>localArrayList.get(0)</code>方法取出的也是个Object类型，当进行赋值操作的时候会强转为泛型类型，注意是赋值操作时才会强转，因为可以观察到<code>localArrayList.get(1)</code>并没有强转</li></ol><ul><li>一些常见的字节码指令<ul><li><code>xloadi</code>：将局部变量区中的第i个变量/引用压入操作数栈区</li><li><code>xstorei</code>：将操作数栈区栈顶的变量/引用提出栈并存入局部变量区的第i个位置</li><li><code>invokexxx</code>：调用方法</li><li><code>getfield</code>：获取非静态字段值</li><li><code>getstatic</code>：获取静态字段值</li></ul></li></ul><h3 id="例子二（带泛型上界的擦除）："><a href="#例子二（带泛型上界的擦除）：" class="headerlink" title="例子二（带泛型上界的擦除）："></a>例子二（带泛型上界的擦除）：</h3><p>注意：编译带有依赖关系的java文件时，需要一起编译</p><blockquote><p>javac -d build Human.java HumanSay.java</p></blockquote><p>源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Human.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Human</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">say</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// HumanSay.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HumanSay</span>&lt;<span class="title">T</span> <span class="keyword">extends</span> <span class="title">Human</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> T t;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HumanSay</span><span class="params">(<span class="keyword">final</span> T t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.t = t;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">proxySay</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        t.say();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> t;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//HumanSay.class</span></span><br><span class="line"></span><br><span class="line"> <span class="keyword">public</span> cn.jasonren.javalearn.generic.HumanSay(T);</span><br><span class="line">    descriptor: (Lcn/jasonren/javalearn/generic/Human;)V</span><br><span class="line">    flags: ACC_PUBLIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=<span class="number">2</span>, locals=<span class="number">2</span>, args_size=<span class="number">2</span></span><br><span class="line">         <span class="number">0</span>: aload_0</span><br><span class="line">         1: invokespecial #1                  // Method java/lang/Object."&lt;init&gt;":()V</span><br><span class="line">         <span class="number">4</span>: aload_0</span><br><span class="line">         <span class="number">5</span>: aload_1</span><br><span class="line">         6: putfield      #2                  // Field (替换泛型为上界) t:Lcn/jasonren/javalearn/generic/Human;</span><br><span class="line">         <span class="number">9</span>: <span class="keyword">return</span></span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line <span class="number">11</span>: <span class="number">0</span></span><br><span class="line">        line <span class="number">12</span>: <span class="number">4</span></span><br><span class="line">        line <span class="number">13</span>: <span class="number">9</span></span><br><span class="line">    Signature: #14                          // (TT;)V</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">proxySay</span><span class="params">()</span></span>;</span><br><span class="line">    descriptor: ()V</span><br><span class="line">    flags: ACC_PUBLIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=<span class="number">1</span>, locals=<span class="number">1</span>, args_size=<span class="number">1</span></span><br><span class="line">         <span class="number">0</span>: aload_0</span><br><span class="line">         1: getfield      #2                  // Field（替换反省为上界） t:Lcn/jasonren/javalearn/generic/Human;</span><br><span class="line">         4: invokeinterface #3,  1            // InterfaceMethod cn/jasonren/javalearn/generic/Human.say:()V</span><br><span class="line">         <span class="number">9</span>: <span class="keyword">return</span></span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line <span class="number">16</span>: <span class="number">0</span></span><br><span class="line">        line <span class="number">17</span>: <span class="number">9</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> T <span class="title">get</span><span class="params">()</span></span>;</span><br><span class="line">    descriptor: ()Lcn/jasonren/javalearn/generic/Human;</span><br><span class="line">    flags: ACC_PUBLIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=<span class="number">1</span>, locals=<span class="number">1</span>, args_size=<span class="number">1</span></span><br><span class="line">         <span class="number">0</span>: aload_0</span><br><span class="line">         1: getfield      #2                  // Field（替换泛型为上界） t:Lcn/jasonren/javalearn/generic/Human;</span><br><span class="line">         <span class="number">4</span>: areturn</span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line <span class="number">20</span>: <span class="number">0</span></span><br><span class="line">    Signature: #19                          // ()TT;</span><br></pre></td></tr></table></figure><p>反编译后的代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HumanSay</span>&lt;<span class="title">T</span> <span class="keyword">extends</span> <span class="title">Human</span>&gt;</span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">  <span class="keyword">private</span> T t;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">HumanSay</span><span class="params">(T paramT)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.t = paramT;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">proxySay</span><span class="params">()</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.t.say();</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> T <span class="title">get</span><span class="params">()</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.t;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从上面的字节码和反编译结果可以看出，虽然泛型信息都被擦除了，但是和之前不同是擦除为Human类型，并非之前的Object类型。</p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ol><li><a href="https://juejin.im/post/5b624f4d518825068302aee9" target="_blank" rel="noopener">几道让你拿offer的面试题</a></li><li><a href="https://blog.csdn.net/u012706811/article/details/53464612" target="_blank" rel="noopener">泛型擦除分析</a></li><li><a href="http://blog.hakugyokurou.net/?p=409" target="_blank" rel="noopener">Java字节码(Bytecode)与ASM简单说明</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;&lt;p&gt;语法糖可以看做编译器实现的一些「小把戏」，这些「小把戏」用得好，可能会使得代码效率提升喔&lt;/p&gt;&lt;/blockquote&gt;&lt;h2 id=&quot;自动装箱的陷阱&quot;&gt;&lt;a href=&quot;#自动装箱的陷阱&quot; class=&quot;headerlink&quot; title=&quot;自动装箱的陷阱&quot;&gt;&lt;/a&gt;自动装箱的陷阱&lt;/h2&gt;&lt;p&gt;先来看看《深入理解JVM虚拟机》的一道题：&lt;/p&gt;&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;testInteger&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(String[] args)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        Integer a = &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        Integer b = &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        Integer c = &lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        Integer d = &lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        Integer e = &lt;span class=&quot;number&quot;&gt;321&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        Integer f = &lt;span class=&quot;number&quot;&gt;321&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        Long g = &lt;span class=&quot;number&quot;&gt;3L&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        Long h = &lt;span class=&quot;number&quot;&gt;3L&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        System.out.println(c == d);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        System.out.println(e == f);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        System.out.println(e.equals(f));&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        System.out.println(c == (a + b));&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        System.out.println(c.equals(a + b));&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        System.out.println(g == (a + b));&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        System.out.println(g.equals(a + b));&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        System.out.println(g.equals(a + h));&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="Java" scheme="https://jasonren.top/categories/Java/"/>
    
    
      <category term="JVM" scheme="https://jasonren.top/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>将Java中的代理一网打尽</title>
    <link href="https://jasonren.top/2018/07/28/Java%E4%B8%AD%E7%9A%84%E4%BB%A3%E7%90%86/"/>
    <id>https://jasonren.top/2018/07/28/Java中的代理/</id>
    <published>2018-07-27T16:00:00.000Z</published>
    <updated>2018-11-22T07:51:49.930Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>代理模式(Proxy Pattern)：给某个对象提供一个代理，并由代理对象控制对原对象的引用</p></blockquote><p>用通俗一点的话来说就是当前对象不愿意干的，没法干的东西委托给别的对象来做，我只要做好本职工作就好了！</p><p>按照代理类的创建时期，代理类分为两种：</p><ul><li>静态代理类：由程序员创建或者由特定工具自动生成源代码，再对其编译。在程序运行前，代理类的.class文件就已经存在了。</li><li>动态代理类：在程序运行时，运用反射机制动态创建而成。</li></ul><a id="more"></a><h2 id="静态代理（用代码描述代理模式）"><a href="#静态代理（用代码描述代理模式）" class="headerlink" title="静态代理（用代码描述代理模式）"></a>静态代理（用代码描述代理模式）</h2><p>首先有个程序员接口，他们每天的工作就是写代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Programmer</span> </span>&#123;</span><br><span class="line">    <span class="comment">//程序员们每天写代码</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">coding</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Jason也是个程序员，他也每天写代码，每个程序员写的代码功能都不一样，所以分为接口和实现类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Jason</span> <span class="keyword">implements</span> <span class="title">Programmer</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">coding</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Jason最新文章:......什么是代理模式......"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为了让自己写的文章让更多的人看到，他需要成为一个网红，但是很多平台并不支持自己给自己点赞（<strong>当前对象无法自己做</strong>）<br>于是他想请程序员大佬给自己点赞、评论、支持自己的文章。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProgrammerBigV</span> <span class="keyword">implements</span> <span class="title">Programmer</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//指定程序员大佬要让谁先发文章</span></span><br><span class="line">    <span class="keyword">private</span> Jason jason;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ProgrammerBigV</span><span class="params">(Jason jason)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.jason = jason;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//大佬点赞评论收藏转发</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">upvote</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"程序员大V点赞评论收藏转发！"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addMoney</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"这次我要加100块"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">coding</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//让Jason发文章</span></span><br><span class="line">        jason.coding();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//程序员大V点赞评论收藏转发！</span></span><br><span class="line">        upvote();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>文章还是由Jason来写，但是每次发送程序员大佬都会点赞。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testProxy</span><span class="params">()</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">        <span class="comment">//想要发达的jason</span></span><br><span class="line">        Jason jason = <span class="keyword">new</span> Jason();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//拜托程序员大V</span></span><br><span class="line">        Programmer programmer = <span class="keyword">new</span> ProgrammerBigV(jason);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//大V让jason发文章，大V来点赞转发</span></span><br><span class="line">        programmer.coding();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://ws1.sinaimg.cn/large/73d640f7ly1ftpyhpvyxqj213403a0tr.jpg" alt=""></p><p>这样一来，不明真相的吃瓜群众觉得jason真的强，为知识买单。</p><h2 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a>动态代理</h2><p>过了一段时间，jason靠着点赞还是没能发家致富，他觉得一定是自己的点赞技巧被识破了，光靠大佬给自己点赞远远不够，他需要雇一波水军：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProgrammerBigV</span> <span class="keyword">implements</span> <span class="title">Programmer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Jason jason = <span class="keyword">new</span> Jason();</span><br><span class="line"></span><br><span class="line">        Programmer programmerWaterArmy = (Programmer) Proxy.newProxyInstance(jason.getClass().getClassLoader(),</span><br><span class="line">            jason.getClass().getInterfaces(), (proxy, method, args1) -&gt; &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//如果是调用coding方法，那么水军就要点赞了</span></span><br><span class="line">            <span class="keyword">if</span> (method.getName().equals(<span class="string">"coding"</span>)) &#123;</span><br><span class="line">                method.invoke(jason, args);</span><br><span class="line">                System.out.println(<span class="string">"我是水军，我来点赞了！"</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//如果不是调用coding方法，那么调用原对象的方法</span></span><br><span class="line">                <span class="keyword">return</span> method.invoke(jason, args);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//每当jason写完文章，水军都会点赞</span></span><br><span class="line">        programmerWaterArmy.coding();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>每次jason发完文章后，水军就开始点赞：<br><img src="https://ws1.sinaimg.cn/large/73d640f7ly1ftpyhpv26cj20z003cq3r.jpg" alt=""></p><h2 id="动态代理调用过程"><a href="#动态代理调用过程" class="headerlink" title="动态代理调用过程"></a>动态代理调用过程</h2><p>Java提供了一个Proxy类，调用它的newProxyInstance方法可以生成某个对象的代理对象，该方法签名如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@CallerSensitive</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title">newProxyInstance</span><span class="params">(ClassLoader loader,</span></span></span><br><span class="line"><span class="function"><span class="params">                                          Class&lt;?&gt;[] interfaces,</span></span></span><br><span class="line"><span class="function"><span class="params">                                          InvocationHandler h)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> IllegalArgumentException</span></span><br></pre></td></tr></table></figure><ul><li>参数一：生成代理对象使用哪个类装载器【一般我们使用的是被代理类的装载器】</li><li>参数二：生成哪个对象的代理对象，通过接口指定【指定要被代理类的接口】</li><li>参数三：生成的代理对象的方法里干什么事【实现handler接口，我们想怎么实现就怎么实现】</li></ul><p>在编写动态代理之前，要明确几个概念：</p><ul><li>代理对象拥有与目标对象完全相同的方法【因为参数二制定了对象的接口，代理对象会实现接口所有方法】</li><li>用户调用代理对象的什么方法，都是在调用处理器的invoke方法。【被拦截】</li><li>使用JDK动态代理必须要有接口【参数二需要接口】<br>代理对象会实现接口的所有方法，这些实现的方法交给我们的handler来处理，所有通过动态代理实现的方法全部通过<code>invoke</code>调用</li></ul><p><img src="https://ws1.sinaimg.cn/large/73d640f7ly1ftpznrwmxpj21cu0kgdpz.jpg" alt=""></p><p><strong>动态代理调用的整个流程</strong>如下图所示：</p><p><img src="https://ws1.sinaimg.cn/large/73d640f7ly1ftpykt6di5j214c0bgq3z.jpg" alt="动态代理调用过程"></p><h2 id="实现动态代理的方式"><a href="#实现动态代理的方式" class="headerlink" title="实现动态代理的方式"></a>实现动态代理的方式</h2><ul><li>JDK动态代理：java.lang.reflect包中的Proxy类和InvocationHandler接口提供了生成动态代理类的能力，其是基于接口来代理的（实现接口的所有方法），如果没有接口的话我们可以考虑cglib代理。</li><li>cglib代理：Code Generation Library，也叫子类代理，运行时在内存中动态生成一个子类对象从而实现对目标对象功能的扩展。</li></ul><p>两者最大的区别：</p><blockquote><p>使用JDK动态代理的对象必须实现一个或多个接口使用</p><p>使用cglib代理的对象则无需实现接口，达到代理类无侵入</p></blockquote><h2 id="动态代理的应用场景"><a href="#动态代理的应用场景" class="headerlink" title="动态代理的应用场景"></a>动态代理的应用场景</h2><ol><li>servlet的filter</li><li>spring的aop及struts2的拦截器</li><li>mybatis分页插件</li><li>日志拦截、事务拦截、权限拦截</li></ol><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ol><li><a href="https://juejin.im/post/5af0335c6fb9a07ace58cc8f" target="_blank" rel="noopener">Java3y给女朋友讲解什么是代理模式</a></li><li><a href="http://www.hollischuang.com/archives/2601" target="_blank" rel="noopener">所有和Java中代理有关的知识点都在这了</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;&lt;p&gt;代理模式(Proxy Pattern)：给某个对象提供一个代理，并由代理对象控制对原对象的引用&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;用通俗一点的话来说就是当前对象不愿意干的，没法干的东西委托给别的对象来做，我只要做好本职工作就好了！&lt;/p&gt;&lt;p&gt;按照代理类的创建时期，代理类分为两种：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;静态代理类：由程序员创建或者由特定工具自动生成源代码，再对其编译。在程序运行前，代理类的.class文件就已经存在了。&lt;/li&gt;&lt;li&gt;动态代理类：在程序运行时，运用反射机制动态创建而成。&lt;/li&gt;&lt;/ul&gt;
    
    </summary>
    
      <category term="Java" scheme="https://jasonren.top/categories/Java/"/>
    
    
      <category term="Spring" scheme="https://jasonren.top/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>常用日志系统的配置</title>
    <link href="https://jasonren.top/2018/07/21/@Slf4j%E6%B3%A8%E8%A7%A3%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <id>https://jasonren.top/2018/07/21/@Slf4j注解的使用/</id>
    <published>2018-07-20T16:00:00.000Z</published>
    <updated>2018-11-22T07:51:49.930Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Slf4j注解的正确使用"><a href="#Slf4j注解的正确使用" class="headerlink" title="@Slf4j注解的正确使用"></a>@Slf4j注解的正确使用</h2><ol><li>对于一个Maven项目，首先要在pom.xml中加入以下依赖项：<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.slf4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>slf4j-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.7.5<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.slf4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>slf4j-log4j12<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.7.5<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>log4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>log4j<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2.17<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.projectlombok<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lombok<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.16.18<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>provided<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ol><ul><li><code>slf4j</code>就是众多接口的集合，它不负责具体的日志实现，只在编译时负责寻找合适的日志系统进行绑定。具体有哪些接口，全部都定义在slf4j-api中。</li><li><code>slf4j-log4j12</code>是链接slf4j-api和log4j中间的适配器。它实现了slf4j-apiz中StaticLoggerBinder接口，从而使得在编译时绑定的是slf4j-log4j12的getSingleton()方法。</li><li><code>log4j</code>是具体的日志系统。通过slf4j-log4j12初始化Log4j，达到最终的日志输出。</li><li><code>lombok</code>：一个插件，封装了log的get和set，可以直接使用log来输出日志信息。</li></ul><a id="more"></a><ol start="2"><li>打开idea插件下载频道，下载Lombok Plugin这个插件，也可以移步<a href="http://plugins.jetbrains.com/plugin/6317-lombok-plugin" target="_blank" rel="noopener">这里</a>。<br><img src="https://ws1.sinaimg.cn/large/73d640f7gy1ftl9vy87a5j20vq0mgjuu.jpg" alt="Lombok Plugin"></li><li>在resource目录下加入log4j.properties<br>基本配置如下：</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">### 设置###</span></span><br><span class="line">log4j.rootLogger = debug,stdout</span><br><span class="line"></span><br><span class="line"><span class="comment">### 输出信息到控制抬 ###</span></span><br><span class="line">log4j.appender.stdout = org.apache.log4j.ConsoleAppender</span><br><span class="line">log4j.appender.stdout.Target = System.out</span><br><span class="line">log4j.appender.stdout.layout = org.apache.log4j.PatternLayout</span><br><span class="line">log4j.appender.stdout.layout.ConversionPattern = %c %d&#123;ISO8601&#125; -- %p -- %m%n</span><br></pre></td></tr></table></figure><ol start="4"><li>可以在代码中像如下例子中一样使用@Slf4j注解<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassUtil</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Class&lt;?&gt; loadClass(String className)&#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> Class.forName(className);</span><br><span class="line">        &#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">            log.error(<span class="string">"load class error"</span>, e);</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h2 id="logback日志系统的使用"><a href="#logback日志系统的使用" class="headerlink" title="logback日志系统的使用"></a>logback日志系统的使用</h2><ol><li>对于一个Maven项目，首先要在pom.xml中加入以下依赖项：</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>ch.qos.logback<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>logback-classic<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.1.7<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.slf4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>slf4j-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.7.21<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><ol start="2"><li>在resource目录下加入配置logback.xml</li></ol><p>基本配置如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8" ?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">appender</span> <span class="attr">name</span>=<span class="string">"STDOUT"</span> <span class="attr">class</span>=<span class="string">"ch.qos.logback.core.ConsoleAppender"</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- encoders are assigned the type</span></span><br><span class="line"><span class="comment">             ch.qos.logback.classic.encoder.PatternLayoutEncoder by default --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">encoder</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">pattern</span>&gt;</span>%d&#123;HH:mm:ss.SSS&#125; [%thread] %-5level %logger&#123;36&#125; - %msg%n<span class="tag">&lt;/<span class="name">pattern</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">encoder</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">appender</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">root</span> <span class="attr">level</span>=<span class="string">"debug"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">"STDOUT"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">root</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure><ol start="3"><li>可在代码中使用logger对象</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyTask</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** logger */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger LOGGER = LoggerFactory.getLogger(MyTask.class);</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="comment">/**/)&#123;</span></span><br><span class="line"><span class="comment">            LOGGER.info("线程还在执行呢...");</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br></pre></td></tr></table></figure><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ol><li><a href="https://blog.csdn.net/wangjie123end/article/details/77235853" target="_blank" rel="noopener">JavaWeb日志管理---@Slf4j注解</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Slf4j注解的正确使用&quot;&gt;&lt;a href=&quot;#Slf4j注解的正确使用&quot; class=&quot;headerlink&quot; title=&quot;@Slf4j注解的正确使用&quot;&gt;&lt;/a&gt;@Slf4j注解的正确使用&lt;/h2&gt;&lt;ol&gt;&lt;li&gt;对于一个Maven项目，首先要在pom.xml中加入以下依赖项：&lt;figure class=&quot;highlight xml&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;dependency&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;groupId&lt;/span&gt;&amp;gt;&lt;/span&gt;org.slf4j&lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;name&quot;&gt;groupId&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;artifactId&lt;/span&gt;&amp;gt;&lt;/span&gt;slf4j-api&lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;name&quot;&gt;artifactId&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;version&lt;/span&gt;&amp;gt;&lt;/span&gt;1.7.5&lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;name&quot;&gt;version&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;name&quot;&gt;dependency&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;dependency&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;groupId&lt;/span&gt;&amp;gt;&lt;/span&gt;org.slf4j&lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;name&quot;&gt;groupId&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;artifactId&lt;/span&gt;&amp;gt;&lt;/span&gt;slf4j-log4j12&lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;name&quot;&gt;artifactId&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;version&lt;/span&gt;&amp;gt;&lt;/span&gt;1.7.5&lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;name&quot;&gt;version&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;name&quot;&gt;dependency&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;dependency&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;groupId&lt;/span&gt;&amp;gt;&lt;/span&gt;log4j&lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;name&quot;&gt;groupId&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;artifactId&lt;/span&gt;&amp;gt;&lt;/span&gt;log4j&lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;name&quot;&gt;artifactId&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;version&lt;/span&gt;&amp;gt;&lt;/span&gt;1.2.17&lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;name&quot;&gt;version&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;name&quot;&gt;dependency&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;dependency&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;groupId&lt;/span&gt;&amp;gt;&lt;/span&gt;org.projectlombok&lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;name&quot;&gt;groupId&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;artifactId&lt;/span&gt;&amp;gt;&lt;/span&gt;lombok&lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;name&quot;&gt;artifactId&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;version&lt;/span&gt;&amp;gt;&lt;/span&gt;1.16.18&lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;name&quot;&gt;version&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;scope&lt;/span&gt;&amp;gt;&lt;/span&gt;provided&lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;name&quot;&gt;scope&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;name&quot;&gt;dependency&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/li&gt;&lt;/ol&gt;&lt;ul&gt;&lt;li&gt;&lt;code&gt;slf4j&lt;/code&gt;就是众多接口的集合，它不负责具体的日志实现，只在编译时负责寻找合适的日志系统进行绑定。具体有哪些接口，全部都定义在slf4j-api中。&lt;/li&gt;&lt;li&gt;&lt;code&gt;slf4j-log4j12&lt;/code&gt;是链接slf4j-api和log4j中间的适配器。它实现了slf4j-apiz中StaticLoggerBinder接口，从而使得在编译时绑定的是slf4j-log4j12的getSingleton()方法。&lt;/li&gt;&lt;li&gt;&lt;code&gt;log4j&lt;/code&gt;是具体的日志系统。通过slf4j-log4j12初始化Log4j，达到最终的日志输出。&lt;/li&gt;&lt;li&gt;&lt;code&gt;lombok&lt;/code&gt;：一个插件，封装了log的get和set，可以直接使用log来输出日志信息。&lt;/li&gt;&lt;/ul&gt;
    
    </summary>
    
      <category term="Java" scheme="https://jasonren.top/categories/Java/"/>
    
    
      <category term="Maven" scheme="https://jasonren.top/tags/Maven/"/>
    
  </entry>
  
  <entry>
    <title>并发线程池就这么简单</title>
    <link href="https://jasonren.top/2018/05/01/%08%E5%B9%B6%E5%8F%91%E7%BA%BF%E7%A8%8B%E6%B1%A0/"/>
    <id>https://jasonren.top/2018/05/01/并发线程池/</id>
    <published>2018-04-30T16:00:00.000Z</published>
    <updated>2018-11-22T07:51:49.930Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>池化最核心的思想就是把宝贵的资源放到池子里，每次使用都从里面获取，用完之后又放回池子供其他人使用。</p></blockquote><p>线程池的好处：</p><ol><li>消除了频繁创建和消亡线程的系统资源开销</li><li>面对过量任务的提交能够平缓地劣化，提高响应速度</li><li>提高线程的可管理性</li></ol><p>《Java开发手册》也有这么一条：</p><p><img src="https://ws1.sinaimg.cn/large/73d640f7ly1fty0e8ntslj219a07eq6h.jpg" alt=""></p><blockquote><p>以下源码为jdk1.8.0_171</p></blockquote><a id="more"></a><h2 id="线程池原理"><a href="#线程池原理" class="headerlink" title="线程池原理"></a>线程池原理</h2><p>JDK主要提供了Executor框架来使用线程池，它是线程池的基础，提供了一种将任务提交与任务执行分开的解耦机制。</p><h3 id="线程池是如何创建的"><a href="#线程池是如何创建的" class="headerlink" title="线程池是如何创建的"></a>线程池是如何创建的</h3><p>先来看看ThreadPoolExecutor的构造函数<br><img src="https://ws1.sinaimg.cn/mw690/73d640f7gy1fu08fk9jbnj20s415ydr7.jpg" alt=""></p><p>创建一个线程一般需要输入几个参数：</p><ul><li><code>corePoolSize</code>：线程池的基本大小，当提交一个任务到线程池，若需要执行的任务没有超过线程池的基本大小，即使当前有其他空闲的基本线程，就创建一个新的线程；</li><li><code>maximumPoolSize</code>：线程池允许的最大线程数，若使用了无界队列此参数就没什么效果；</li><li><code>keepAliveTime</code>：线程活动保持时间，即线程池的工作线程空闲后保持存活的时间；</li><li><code>unit</code>：线程活动保持时间的单位；</li><li><code>workQueue</code>：任务队列，用于保存等待执行的任务的阻塞队列；</li><li><code>threadFactory</code>：用于设置创建线程的工厂，可通过它给创建出来的线程设置更有意义的名字，默认的DefaultThreadFactory名字为<code>namePrefix = &quot;pool-&quot; + poolNumber.getAndIncrement() +&quot;-thread-&quot; + threadNumber.getAndIncrement()</code>；</li><li><code>handler</code>：饱和策略，当任务队列和线程池都满了的时候，必须采取一种策略处理新的任务，默认为AbortPolicy，无法处理新任务时抛出异常<ul><li>AbortPolicy：直接拒绝所提交的任务，抛出RejectedExecutionException异常</li><li>CallerRunsPolicy：只用调用者所在线程来执行任务</li><li>DiscardPolicy：不处理直接丢弃掉任务</li><li>DiscardOldestPolicy：丢弃掉阻塞队列中存放时间的任务并重试execute()</li></ul></li></ul><h2 id="线程池的状态"><a href="#线程池的状态" class="headerlink" title="线程池的状态"></a>线程池的状态</h2><p>定义一个AtomicInteger类型的ctl来标识线程池的状态，高三位表示「线程池状态」，低三位表示「线程池中的任务数量」。</p><p>线程池状态标识意义：</p><ul><li>RUNNING （111）：能接收新任务并且处理在队列中的任务</li><li>SHUTDOWN （000）：不接收新任务，只能处理已经提交的任务</li><li>STOP （001）：不接收新任务，也不处理已提交的任务，并中断正在处理的任务</li><li>TIDYING （010）：当所有的任务已终止，ctl记录的“任务数量”为0，线程池会变为TIDYING状态，且执行钩子函数terminated()，若想在线程池变为此状态时添加处理逻辑，可重载terminated()方法</li><li>TERMINATED（011）：terminated()方法执行完毕，线程池彻底终止</li></ul><p>状态转移如下图：</p><p><img src="https://ws1.sinaimg.cn/mw690/73d640f7gy1fu08fk2nsoj20w40dwq72.jpg" alt=""></p><h2 id="新任务到达，线程池如何处理"><a href="#新任务到达，线程池如何处理" class="headerlink" title="新任务到达，线程池如何处理"></a>新任务到达，线程池如何处理</h2><p>当提交一个新任务到线程池时，会经历如下步骤：</p><ol><li>如果当前运行的线程少于corePoolSize，则会创建新的线程来执行新的任务；</li><li>如果运行的线程个数等于或者大于corePoolSize，则会将提交的任务存放到阻塞队列workQueue中；</li><li>如果当前workQueue队列已满的话，则会创建新的线程来执行任务（执行这一步需要获取全局锁）；</li><li>如果线程个数已经超过了maximumPoolSize，则会使用饱和策略RejectedExecutionHandler来进行处理。</li></ol><p>提交任务的核心函数为<code>execute()</code>，其处理逻辑为：<br><img src="https://ws1.sinaimg.cn/large/73d640f7ly1fty74ibpzmj21cc0z64fk.jpg" alt=""></p><p><code>execute()</code>源码为：<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable command)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//如果没有任务，报空指针异常</span></span><br><span class="line">        <span class="keyword">if</span> (command == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">        <span class="comment">//获取当前线程池的状态</span></span><br><span class="line">        <span class="keyword">int</span> c = ctl.get();</span><br><span class="line">        <span class="comment">//如果工作线程数量小于corePoolSize，创建一个新的线程</span></span><br><span class="line">        <span class="keyword">if</span> (workerCountOf(c) &lt; corePoolSize) &#123;</span><br><span class="line">            <span class="comment">//如果添加成功就直接返回</span></span><br><span class="line">            <span class="keyword">if</span> (addWorker(command, <span class="keyword">true</span>))</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            <span class="comment">//否则再次获取活动线程数量</span></span><br><span class="line">            c = ctl.get();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//否则如果当前线程处于运行状态且写入阻塞队列成功，则进行二次检查</span></span><br><span class="line">        <span class="keyword">if</span> (isRunning(c) &amp;&amp; workQueue.offer(command)) &#123;</span><br><span class="line">            <span class="comment">//再次对线程池状态检查，因为上面addWorke()过了并且失败了，所以需要检查</span></span><br><span class="line">            <span class="keyword">int</span> recheck = ctl.get();</span><br><span class="line">            <span class="comment">//如果线程池不是运行状态，就需要从阻塞队列移除任务，同时执行拒绝策略</span></span><br><span class="line">            <span class="keyword">if</span> (! isRunning(recheck) &amp;&amp; remove(command))</span><br><span class="line">                reject(command);</span><br><span class="line">            <span class="comment">//如果当前线程池为空（线程池已关闭），则添加一个null到队列中</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (workerCountOf(recheck) == <span class="number">0</span>)</span><br><span class="line">                <span class="comment">//添加一个空的任务</span></span><br><span class="line">                addWorker(<span class="keyword">null</span>, <span class="keyword">false</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//上述if判断为非运行状态，尝试新建线程，如果失败则执行拒绝策略</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (!addWorker(command, <span class="keyword">false</span>))</span><br><span class="line">            reject(command);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p></p><h2 id="创建线程池的addWorker-方法"><a href="#创建线程池的addWorker-方法" class="headerlink" title="创建线程池的addWorker()方法"></a>创建线程池的addWorker()方法</h2><p>该方法签名为</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">addWorker</span><span class="params">(Runnable firstTask, <span class="keyword">boolean</span> core)</span></span></span><br></pre></td></tr></table></figure><p>第一个参数为<code>Runnable</code>类型，表示线程池中某个新提交的任务，第二参数如果为true，创建<code>core</code>核心线程，如果为false，则创建<code>maximumPoolSize</code>线程，这两类线程的生命周期不同。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">boolean</span> workerStarted = <span class="keyword">false</span>;</span><br><span class="line">      <span class="keyword">boolean</span> workerAdded = <span class="keyword">false</span>;</span><br><span class="line">      Worker w = <span class="keyword">null</span>;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">           <span class="comment">//创建一个Worker对象</span></span><br><span class="line">     <span class="comment">// 其代理了任务对象，并通过线程工厂创建线程</span></span><br><span class="line">          w = <span class="keyword">new</span> Worker(firstTask);</span><br><span class="line">          <span class="keyword">final</span> Thread t = w.thread;</span><br><span class="line">          <span class="keyword">if</span> (t != <span class="keyword">null</span>) &#123;</span><br><span class="line">              <span class="keyword">final</span> ReentrantLock mainLock = <span class="keyword">this</span>.mainLock;</span><br><span class="line">              mainLock.lock();</span><br><span class="line">              <span class="keyword">try</span> &#123;</span><br><span class="line">                  <span class="comment">// Recheck while holding lock.</span></span><br><span class="line">                  <span class="comment">// Back out on ThreadFactory failure or if</span></span><br><span class="line">                  <span class="comment">// shut down before lock acquired.</span></span><br><span class="line">                  <span class="keyword">int</span> rs = runStateOf(ctl.get());</span><br><span class="line"><span class="comment">// rs &lt; SHUTDOWN表示是RUNNING状态</span></span><br><span class="line">                  <span class="comment">// 如果rs是RUNNING状态或者rs是SHUTDOWN状态并且firstTask是null，向线程池添加线程</span></span><br><span class="line">                  <span class="comment">// 因为在SHUTDOWN时不会再添加新任务，但还是会执行workQueue中的任务</span></span><br><span class="line">                  <span class="keyword">if</span> (rs &lt; SHUTDOWN ||</span><br><span class="line">                      (rs == SHUTDOWN &amp;&amp; firstTask == <span class="keyword">null</span>)) &#123;</span><br><span class="line">                      <span class="keyword">if</span> (t.isAlive()) <span class="comment">// precheck that t is startable</span></span><br><span class="line">                          <span class="keyword">throw</span> <span class="keyword">new</span> IllegalThreadStateException();</span><br><span class="line">                      <span class="comment">// workers是一个拥有所有线程的HashSet，当获得全局锁才可访问</span></span><br><span class="line">                      workers.add(w);</span><br><span class="line">                      <span class="comment">// largestPoolSize记录着线程池中出现过的最大线程数量</span></span><br><span class="line">                      <span class="keyword">int</span> s = workers.size();</span><br><span class="line">                      <span class="keyword">if</span> (s &gt; largestPoolSize)</span><br><span class="line">                          largestPoolSize = s;</span><br><span class="line">                      workerAdded = <span class="keyword">true</span>;</span><br><span class="line">                  &#125;</span><br><span class="line">              &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                  mainLock.unlock();</span><br><span class="line">              &#125;</span><br><span class="line">              <span class="keyword">if</span> (workerAdded) &#123;</span><br><span class="line">                  <span class="comment">//启动线程</span></span><br><span class="line">                  t.start();</span><br><span class="line">                  workerStarted = <span class="keyword">true</span>;</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">          <span class="keyword">if</span> (! workerStarted)</span><br><span class="line">              addWorkerFailed(w);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> workerStarted;</span><br></pre></td></tr></table></figure><p>Worker类的签名及构造方法签名如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Worker类继承了AQS并实现了Runnable接口</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Worker</span></span></span><br><span class="line"><span class="class">        <span class="keyword">extends</span> <span class="title">AbstractQueuedSynchronizer</span></span></span><br><span class="line"><span class="class">        <span class="keyword">implements</span> <span class="title">Runnable</span></span></span><br><span class="line"><span class="class">// 构造函数</span></span><br><span class="line"><span class="class"><span class="title">Worker</span>(<span class="title">Runnable</span> <span class="title">firstTask</span>) </span>&#123;</span><br><span class="line">            setState(-<span class="number">1</span>); <span class="comment">// inhibit interrupts until runWorker</span></span><br><span class="line">            <span class="keyword">this</span>.firstTask = firstTask;</span><br></pre></td></tr></table></figure><p><strong>注意</strong>：在执行<code>t.start()</code>时，由于<code>this.thread = getThreadFactory().newThread(this)</code>会传入this指针，会间接调用实现了Runnable接口的Worker类的run方法。</p><p>Worker类的run方法实现如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            runWorker(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="线程池最核心的方法runWorker-方法"><a href="#线程池最核心的方法runWorker-方法" class="headerlink" title="线程池最核心的方法runWorker()方法"></a>线程池最核心的方法runWorker()方法</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">runWorker</span><span class="params">(Worker w)</span> </span>&#123;</span><br><span class="line">        Thread wt = Thread.currentThread();</span><br><span class="line">    <span class="comment">//获取第一个任务</span></span><br><span class="line">        Runnable task = w.firstTask;</span><br><span class="line">        w.firstTask = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">//允许中断</span></span><br><span class="line">        w.unlock(); <span class="comment">// allow interrupts</span></span><br><span class="line">        <span class="keyword">boolean</span> completedAbruptly = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (task != <span class="keyword">null</span> || (task = getTask()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                w.lock();</span><br><span class="line">                <span class="comment">// If pool is stopping, ensure thread is interrupted;</span></span><br><span class="line">                <span class="comment">// if not, ensure thread is not interrupted.  This</span></span><br><span class="line">                <span class="comment">// requires a recheck in second case to deal with</span></span><br><span class="line">                <span class="comment">// shutdownNow race while clearing interrupt</span></span><br><span class="line">                <span class="keyword">if</span> ((runStateAtLeast(ctl.get(), STOP) ||</span><br><span class="line">                     (Thread.interrupted() &amp;&amp;</span><br><span class="line">                      runStateAtLeast(ctl.get(), STOP))) &amp;&amp;</span><br><span class="line">                    !wt.isInterrupted())</span><br><span class="line">                    wt.interrupt();</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    beforeExecute(wt, task);</span><br><span class="line">                    Throwable thrown = <span class="keyword">null</span>;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        task.run();</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (RuntimeException x) &#123;</span><br><span class="line">                        thrown = x; <span class="keyword">throw</span> x;</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (Error x) &#123;</span><br><span class="line">                        thrown = x; <span class="keyword">throw</span> x;</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (Throwable x) &#123;</span><br><span class="line">                        thrown = x; <span class="keyword">throw</span> <span class="keyword">new</span> Error(x);</span><br><span class="line">                    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                        afterExecute(task, thrown);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    task = <span class="keyword">null</span>;</span><br><span class="line">                    w.completedTasks++;</span><br><span class="line">                    w.unlock();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            completedAbruptly = <span class="keyword">false</span>;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            processWorkerExit(w, completedAbruptly);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>总结一下<code>runWorker()</code>的执行过程：</p><ol><li>while循环不断地通过<code>getTask()</code>方法获取任务</li><li><code>getTask()</code>方法从阻塞队列中获取任务</li><li>如果线程池正在停止，要保证当前线程是中断状态；如果不是的话，则要保证当前线程不是中断状态</li><li>调用<code>task.run()</code>执行任务</li><li>如果task为null，则跳出循环，执行<code>processWorkerExit()</code>方法</li><li><code>runWorker()</code>方法执行完成，也即Worker中的<code>run()</code>方法，也即<code>addWorker()</code>中的<code>t.start()</code>方法执行完毕，销毁线程</li></ol><p>注意：</p><p><code>beforeExecute()</code>和<code>afterExecute()</code>在ThreadExecutor中是空的，可以自行扩展功能。</p><h2 id="线程池关闭"><a href="#线程池关闭" class="headerlink" title="线程池关闭"></a>线程池关闭</h2><p>ThreadPoolExecutor提供了<code>shutdown()</code>和<code>shutdownNow()</code>两个方法来关闭线程</p><p><code>shutdown()</code>按照过去任务提交的顺序发起一个有序的关闭，不接受新任务</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">shutdown</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> ReentrantLock mainLock = <span class="keyword">this</span>.mainLock;</span><br><span class="line">        <span class="comment">//加上可重入锁</span></span><br><span class="line">        mainLock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            checkShutdownAccess();</span><br><span class="line">            advanceRunState(SHUTDOWN); <span class="comment">// 设置线程池状态为SHUTDOWN</span></span><br><span class="line">            interruptIdleWorkers();    <span class="comment">//中断空闲线程</span></span><br><span class="line">            onShutdown(); <span class="comment">// hook for ScheduledThreadPoolExecutor</span></span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            mainLock.unlock();         <span class="comment">//释放锁</span></span><br><span class="line">        &#125;</span><br><span class="line">        tryTerminate();                <span class="comment">//将线程池状态设置为TERMINATED</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><code>shutdownNow()</code>也是停止接收新任务，但会中断所有任务，将线程池状态变为TERMINATED</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Runnable&gt; <span class="title">shutdownNow</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        List&lt;Runnable&gt; tasks;</span><br><span class="line">        <span class="keyword">final</span> ReentrantLock mainLock = <span class="keyword">this</span>.mainLock;</span><br><span class="line">        mainLock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            checkShutdownAccess();     </span><br><span class="line">            advanceRunState(STOP);    <span class="comment">//设置线程池状态为STOP</span></span><br><span class="line">            interruptWorkers();       <span class="comment">//中断所有线程</span></span><br><span class="line">            tasks = drainQueue();     <span class="comment">//获取等待的任务列表</span></span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            mainLock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">        tryTerminate();               </span><br><span class="line">        <span class="keyword">return</span> tasks;                 <span class="comment">//返回等待的任务列表</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>区别：</p><ul><li>调用shutdown()后，线程池状态立刻变为SHUTDOWN，而调用shutdownNow()，线程池状态立刻变为STOP；</li><li>shutdown()等待任务执行完才中断线程，而shutdownNow()不等任务执行完就中断了线程。</li></ul><p>Tips: 优雅的线程关闭方式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">5</span>; i++) &#123;</span><br><span class="line">        pool.execute(<span class="keyword">new</span> MyTask());</span><br><span class="line">    &#125;</span><br><span class="line">    pool.shutdown();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!pool.awaitTermination(<span class="number">1</span>, TimeUnit.SECONDS)) &#123;</span><br><span class="line">        LOGGER.info(<span class="string">"线程还在执行呢..."</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">long</span> end = System.currentTimeMillis();</span><br><span class="line">    LOGGER.info(<span class="string">"一共处理了"</span> + (end - start) + <span class="string">"秒"</span>);</span><br></pre></td></tr></table></figure><h2 id="线程池的种类"><a href="#线程池的种类" class="headerlink" title="线程池的种类"></a>线程池的种类</h2><ul><li><strong>固定线程池</strong> ExecutorService service1 = Executors.newFixedThreadPool(5)</li><li><strong>单例线程池</strong> ExecutorService service2 = Executors.newSingleThreadExecutor();</li><li><strong>缓存线程池</strong> ExecutorService service3 = Executors.newCachedThreadPool();</li><li><strong>任务调用线程池</strong> ExecutorService service4 = Executors.newScheduledThreadPool(2);</li></ul><h3 id="newFixedThreadPool"><a href="#newFixedThreadPool" class="headerlink" title="newFixedThreadPool"></a>newFixedThreadPool</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newFixedThreadPool</span><span class="params">(<span class="keyword">int</span> nThreads)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(nThreads, nThreads,</span><br><span class="line">                                      <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                                      <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;());</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>其中corePoolSize等于maximumPoolSize。</p><h3 id="newCachedThreadPool"><a href="#newCachedThreadPool" class="headerlink" title="newCachedThreadPool"></a>newCachedThreadPool</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newCachedThreadPool</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">0</span>, Integer.MAX_VALUE,</span><br><span class="line">                                      <span class="number">60L</span>, TimeUnit.SECONDS,</span><br><span class="line">                                      <span class="keyword">new</span> SynchronousQueue&lt;Runnable&gt;());</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>无限线程池，接收到新任务线程池会毫不犹豫地新开一个线程处理。</p><h3 id="newSingleThreadExecutor"><a href="#newSingleThreadExecutor" class="headerlink" title="newSingleThreadExecutor"></a>newSingleThreadExecutor</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newSingleThreadExecutor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> FinalizableDelegatedExecutorService</span><br><span class="line">            (<span class="keyword">new</span> ThreadPoolExecutor(<span class="number">1</span>, <span class="number">1</span>,</span><br><span class="line">                                    <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                                    <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;()));</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>创建单个worker线程的线程池。</p><h2 id="SpringBoot中的线程池"><a href="#SpringBoot中的线程池" class="headerlink" title="SpringBoot中的线程池"></a>SpringBoot中的线程池</h2><p>需要导入Guava的包</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">dependency&gt;</span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.google.guava<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>guava<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>11.0.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>首先配置线程池：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadPoolConfig</span> </span>&#123;</span><br><span class="line">    <span class="comment">//消费线程队列</span></span><br><span class="line">    <span class="meta">@Bean</span>(value=<span class="string">"consumerQueueThreadPool"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ExecutorService <span class="title">buildConsumerQueueThreadPool</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ThreadFactory namedThreadFactory = <span class="keyword">new</span> ThreadFactoryBuilder()</span><br><span class="line">            .setNameFormat(<span class="string">"consumer-queue-thread-%d"</span>).build();</span><br><span class="line">        ExecutorService pool = <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">5</span>, <span class="number">5</span>, <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">            <span class="keyword">new</span> ArrayBlockingQueue&lt;Runnable&gt;(<span class="number">5</span>), namedThreadFactory, <span class="keyword">new</span> ThreadPoolExecutor.AbortPolicy());</span><br><span class="line">        <span class="keyword">return</span> pool;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>直接使用配置好的消费队列线程池Bean：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Resource</span>(name = <span class="string">"consumerQueueThreadPool"</span>)</span><br><span class="line">    <span class="keyword">private</span> ExecutorService consumerQueueThreadPool;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//消费队列</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            consumerQueueThreadPool.execute(<span class="keyword">new</span> ConsumerQueueThread());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ol><li><a href="http://www.ideabuffer.cn/2017/04/04/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E7%BA%BF%E7%A8%8B%E6%B1%A0%EF%BC%9AThreadPoolExecutor/#addWorker%E6%96%B9%E6%B3%95" target="_blank" rel="noopener">深入理解Java线程池</a></li><li><a href="http://thinkinjava.cn/2018/01/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B9%8B%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E4%BD%BF%E7%94%A8%E5%8F%8A%E6%89%A9%E5%B1%95%E5%92%8C%E4%BC%98%E5%8C%96/" target="_blank" rel="noopener">并发编程之线程池的使用及扩展和优化</a></li><li><a href="http://thinkinjava.cn/2018/01/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B9%8B-%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90-%E7%BA%BF%E7%A8%8B%E6%B1%A0-%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/" target="_blank" rel="noopener">剖析线程池实现原理</a></li><li><a href="https://mp.weixin.qq.com/s/kbOV0mkE_NMypEQK6rZW3A" target="_blank" rel="noopener">如何优雅的使用和理解线程池</a></li><li><a href="https://juejin.im/post/5aeec0106fb9a07ab379574f" target="_blank" rel="noopener">线程池ThreadPoolExecutor实现原理</a></li><li>《阿里巴巴Java开发手册》</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;&lt;p&gt;池化最核心的思想就是把宝贵的资源放到池子里，每次使用都从里面获取，用完之后又放回池子供其他人使用。&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;线程池的好处：&lt;/p&gt;&lt;ol&gt;&lt;li&gt;消除了频繁创建和消亡线程的系统资源开销&lt;/li&gt;&lt;li&gt;面对过量任务的提交能够平缓地劣化，提高响应速度&lt;/li&gt;&lt;li&gt;提高线程的可管理性&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;《Java开发手册》也有这么一条：&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;https://ws1.sinaimg.cn/large/73d640f7ly1fty0e8ntslj219a07eq6h.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;以下源码为jdk1.8.0_171&lt;/p&gt;&lt;/blockquote&gt;
    
    </summary>
    
      <category term="Java" scheme="https://jasonren.top/categories/Java/"/>
    
    
      <category term="并发" scheme="https://jasonren.top/tags/%E5%B9%B6%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>线程与进程的区别及其通信方式</title>
    <link href="https://jasonren.top/2018/04/16/%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <id>https://jasonren.top/2018/04/16/进程和线程的区别/</id>
    <published>2018-04-15T16:00:00.000Z</published>
    <updated>2018-11-22T07:51:49.934Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>线程：<strong>是操作系统能够进行运算调度的最小单位</strong>，是进程的一个执行流程，一个进程可以运行多个线程。</p><p>进程：<strong>一个执行中的程序的实例</strong>。</p><a id="more"></a><h2 id="进程与线程的区别"><a href="#进程与线程的区别" class="headerlink" title="进程与线程的区别"></a>进程与线程的区别</h2><ul><li><strong>一个程序至少有一个进程，一个进程至少有一个线程</strong>。</li><li>线程的划分尺度小于进程，是的多线程程序的并发性高。</li><li>另外，<strong>进程在执行过程中拥有独立的内存单元</strong>，而<strong>多个线程共享内存</strong>，从而极大地提高了程序的运行效率。</li><li>线程在执行过程中与进程还是有区别的。每个独立的线程有一个程序运行的入口、顺序执行序列和程序的出口。但是线程不能独立执行，必须依存在应用程序中，由应用程序提供多个线程执行控制。</li><li>从逻辑角度来看，多线程的意义在于一个应用程序中，有多个执行部门可以同时执行。但操作系统并没有将多个线程看作多个独立的应用，来实现进程的调度和管理以及资源分配。这就是进程和线程的重要区别。</li><li>进程是具有一定独立功能的程序关于某个数据集合上的一次运行活动，进程是系统进行资源分配和调度的一个独立单位。</li><li><strong>线程是进程的一个实体，是CPU调度和分派的基本单位</strong>，它是比进程更小的能独立运行的基本单位，线程自己基本上不拥有系统资源，只拥有一点在运行中必不可少的资源（如程序计数器，一组寄存器和栈），但是它可与同属一个进程的其他的线程共享进程所拥有的全部资源。</li><li><strong>一个线程可以创建和撤销另一个线程；同一个进程中的多个线程之间可以并发执行</strong>。</li></ul><p><strong>总结</strong>：</p><p>进程和线程的主要差别在于他们是不同的操作系统资源管理方式，进程有独立的地址空间，一个进程崩溃后，在保护模式下不会对其他进程产生影响，而线程只是一个进程中的不同执行路径。线程有自己的堆栈和局部变量，但线程之间没有单独的地址空间，一个线程死掉就等于整个进程死掉，所以多进程的程序要比多线程的程序健壮，但在进程切换时，耗费资源较大，效率要差一些。对于一些要求同时进行并且又要共享某些变量的并发操作，只能用线程，不能用进程。</p><p>线程一般是<code>new</code>出来的，而进程一般<code>fork</code>某个母体而产生的。</p><h2 id="进程间通信-IPC-Inter-Process-Communication"><a href="#进程间通信-IPC-Inter-Process-Communication" class="headerlink" title="进程间通信(IPC, Inter-Process Communication)"></a>进程间通信(IPC, Inter-Process Communication)</h2><p>在linux下进程间通信的几种主要手段简介：</p><ol><li><strong>管道（Pipe）及有名管道（named pipe）</strong>：管道可用于具有亲缘关系进程间的通信，有名管道克服了管道没有名字的限制，因此，除具有管道所具有的功能外，它还允许无亲缘关系进程间的通信；</li><li><strong>信号（Signal）</strong>：信号是比较复杂的通信方式，用于通知接收进程有某种事件发生，除了用于进程间通信外，进程还可以发送信号给进程本身；linux除了支持Unix早期信号语义函数signal外，还支持语义符合Posix.1标准的信号函数sigaction（实际上，该函数是基于BSD的，BSD为了实现可靠信号机制，又能够统一对外接口，用signaction函数重新实现了signal函数）;</li><li><strong>消息队列（message queue）</strong>：消息队列是消息的链接表，包括Posix消息队列和system V消息队列。有足够权限的进程可以向队列中添加消息，被赋予读权限的进程可以读走队列中的消息。消息队列克服了信号承载信息量少，管道只能承载无格式字节流以及缓冲区大小受限等缺点。</li><li><strong>共享内存（shared memory）</strong>：使得多个进程可以访问同一块内存空间，是最快的可用IPC形式。是针对其他通信机制运行效率较低而设计的。往往与其他通信机制，如信号量结合使用，来达到进程间的同步及互斥。</li><li><strong>信号量（semaphore）</strong>:主要作为进程间以及同一进程不同线程之间的同步手段。</li><li><strong>套接字（Socket）</strong>：更为一般的进程间通信机制，可用于不同机器之间的进程间通信。起初是Unix系统的BSD分支开发出来的，但现在一般可以一直到其他类Unix系统上：Linux和System V的变种都支持套接字。</li></ol><h2 id="线程间通信"><a href="#线程间通信" class="headerlink" title="线程间通信"></a>线程间通信</h2><ol><li>锁机制：包括互斥锁、条件变量、读写锁<ul><li>互斥锁提供了以排他方式防止数据结构被并发修改的方法</li><li>读写锁允许多个线程同时读共享数据，而对写操作是互斥的</li><li>条件变量可以以原子的方式阻塞进程，直到某个特定条件为真为止。对条件的测试是在互斥锁的保护下进行的。条件变量始终与互斥锁一起使用</li></ul></li><li>信号量机制（Semaphore）：包括无名线程信号量和命令线程信号量</li><li>信号机制（Signal）：类似进程间的信号处理</li></ol><p>线程间的通信目的主要用于<strong>线程同步</strong>，所以线程没有像进程通信中的用于数据交换的通信机制</p><h2 id="线程共享资源和独享资源"><a href="#线程共享资源和独享资源" class="headerlink" title="线程共享资源和独享资源"></a>线程共享资源和独享资源</h2><table><thead><tr><th>线程共享资源</th><th>线程独享资源</th></tr></thead><tbody><tr><td>地址空间</td><td>程序计数器</td></tr><tr><td>全局变量</td><td>r寄存器</td></tr><tr><td>打开的文件</td><td>栈</td></tr><tr><td>子进程</td><td>状态字</td></tr><tr><td>闹铃</td><td></td></tr><tr><td>信号及信号服务程序</td><td></td></tr><tr><td>记账信息</td><td></td></tr></tbody></table><h2 id="进程及线程如何实现"><a href="#进程及线程如何实现" class="headerlink" title="进程及线程如何实现"></a>进程及线程如何实现</h2><ul><li><p>首先，进程的调度及创建都是由操作系统实现的，所以说进程的实现只能由操作系统内核来实现，而不存在用户态实现的情况。</p></li><li><p>但是对于线程就不同了，线程的管理者可以是用户也可以是操作系统本身，线程是进程内部的东西，当然存在由进程直接管理线程的可能性。</p></li><li><p>因此线程的实现就应该分为内核态线程实现和用户态线程实现。</p></li></ul><h2 id="线程管理"><a href="#线程管理" class="headerlink" title="线程管理"></a>线程管理</h2><h3 id="内核线程"><a href="#内核线程" class="headerlink" title="内核线程"></a>内核线程</h3><h4 id="管理方式"><a href="#管理方式" class="headerlink" title="管理方式"></a>管理方式</h4><p>首先操作系统像管理进程一样，应该保持维护线程的所有资源，将线程控制块存放在操作系统的内核空间中，此时操作系统就同时掌管进程控制块和线程控制块。</p><h4 id="优点和缺点："><a href="#优点和缺点：" class="headerlink" title="优点和缺点："></a>优点和缺点：</h4><p><strong>优点</strong>是用户编程简单，如果一个线程执行阻塞操作，操作系统可以从容地调度另外一个线程的执行</p><p><strong>缺点</strong>是效率低，因为线程在内核态实现，每次线程切换都需要陷入到内核，由操作系统来调度，而由用户态切换到内核态是要花费很多时间的，另外内核态实现会占用内核稀有的资源，因为操作系统要维护线程列表，操作系统所占内核空间一旦装载后就无法动态改变，并且线程的数量远远大于进程的数量，随着线程数的增加内核将耗尽；内核态的实现需要修改操作系统，这个是谁都不想要做的事情</p><h3 id="用户态线程"><a href="#用户态线程" class="headerlink" title="用户态线程"></a>用户态线程</h3><h4 id="管理方式-1"><a href="#管理方式-1" class="headerlink" title="管理方式"></a>管理方式</h4><p>用户态管理线程就是用户自己做线程的切换，自己管理线程的信息，操作系统无需知道线程的存在。</p><p>在用户态下进行线程的管理需要用户创建一个调度线程。一个线程在执行完一段时间后主动把资源释放给其它线程使用，而在内核态则无需如此，因为操作系统能够可通过周期性的时钟中断把控制权夺过来，在用户态实现情况下，执行系统的调度器也是线程，没有能力夺取控制权。</p><h4 id="优点及缺点"><a href="#优点及缺点" class="headerlink" title="优点及缺点"></a>优点及缺点</h4><p><strong>优点</strong>是灵活，因为操作系统不用知道线程的存在，所以任何操作系统上都能应用；其次，线程切换快，因为切换在用户态进行，无需陷入带内核态；再次，不用修改操作系统实现容易</p><p><strong>缺点</strong>是首先编程起来很诡异，由于在用户台下各个进程间需要相互合作才能正常运转。那么在编程时必须考虑什么情况下让出CPU，让其他的线程运行，而让出时机的选择对线程的效率和可靠性有很大影响，这个并不容易做到；</p><p>其次，用户态线程实现无法完全达到线程提出所要达到的目的：</p><p><strong>进程级多道编程</strong>：如果在执行过程中一个线程受阻，它将无法将控制权交出来，这样整个进程都无法推进。操作系统随即把CPU控制权交给另外一个进程。这样，一个线程受阻造成整个进程受阻，我们期望的通过线程对进程实施分身的计划就失败了。这是用户态线程致命的缺点。</p><p><strong>调度器激活</strong>：线程阻塞后，CPU控制权交给了操作系统，要激活受阻进程的线程，唯一的办法就是让操作系统在进程切换时先不切换，而是通知受阻的进程执行系统（即调用执行系统），并问其是否还有别的线程可以执行。如果有，将CPU控制权交给该受阻进程的执行系统线程，从而调度另一个可以执行的线程到CPU上。一个进程挂起后，操作系统并不立即切换到别的进程上，而是给该进程二次机会，让其继续执行。如果该进程只有一个线程，或者其所有线程都已经阻塞，则控制权将再次返回给操作系统。而现在，操作系统就会切换到其他线程了。</p><h3 id="现代操作系统的线程实现模型"><a href="#现代操作系统的线程实现模型" class="headerlink" title="现代操作系统的线程实现模型"></a>现代操作系统的线程实现模型</h3><p>鉴于用户态与内核态都存在缺陷，现代操作系统将两者结合起来。<strong>用户态的执行负责进程内部线程在非阻塞时的切换；内核态的操作系统负责阻塞线程的切换，即我们同时实现内核态和用户态线程管理</strong>。每个内核态线程可以服务一个或者多个用户态线程。</p><h3 id="线程从用户态切换到内核态"><a href="#线程从用户态切换到内核态" class="headerlink" title="线程从用户态切换到内核态"></a>线程从用户态切换到内核态</h3><p>首先，如果在程序运行过程中发生中断或者异常，系统将自动切换到内核态来运行中断或异常处理机制；此外，程序进行系统调用也会从用户态切换到内核态</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;概念&quot;&gt;&lt;a href=&quot;#概念&quot; class=&quot;headerlink&quot; title=&quot;概念&quot;&gt;&lt;/a&gt;概念&lt;/h2&gt;&lt;p&gt;线程：&lt;strong&gt;是操作系统能够进行运算调度的最小单位&lt;/strong&gt;，是进程的一个执行流程，一个进程可以运行多个线程。&lt;/p&gt;&lt;p&gt;进程：&lt;strong&gt;一个执行中的程序的实例&lt;/strong&gt;。&lt;/p&gt;
    
    </summary>
    
      <category term="操作系统" scheme="https://jasonren.top/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
      <category term="线程与进程" scheme="https://jasonren.top/tags/%E7%BA%BF%E7%A8%8B%E4%B8%8E%E8%BF%9B%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>高性能UDP QUIC</title>
    <link href="https://jasonren.top/2018/04/15/QUIC%E7%AE%80%E4%BB%8B/"/>
    <id>https://jasonren.top/2018/04/15/QUIC简介/</id>
    <published>2018-04-14T16:00:00.000Z</published>
    <updated>2018-11-22T07:51:49.931Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>源自于一道面试题，面试官问我是否了解高性能UDP</p></blockquote><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p>QUIC是Quick UDP Internet Connection的简称，是Google制定的一种基于UDP的低时延的互联网传输层协议。TCP/IP协议族是互联网的基础。其中传输层协议包括TCP和UDP协议。与TCP协议相比，UDP更为轻量，但是错误校验也要少得多。这意味着UDP往往效率更高（不经常跟服务器端通信查看数据包是否送达或者按序），但是可靠性比不上TCP。通常游戏、流媒体以及VoIP等应用均采用UDP，而网页、邮件、远程登录等大部分的应用均采用TCP。</p><p><img src="https://raw.githubusercontent.com/JasonRen23/imgs/master/QUIC-Figure-1.png" alt="网络分层"></p><a id="more"></a><p>Google想到能否把这两种协议的优势结合起来，同时实现低时延和高可靠并将其应用到更高安全的协议上，于是就有了QUIC。</p><p>以往典型的安全TCP连接（TCP + TLS）往往需要在发送与接收端先进行2、3轮的握手通信才能正式开始数据传输。而利用QUIC协议，如果双方此前通信过的话马上就可以对话（即便双方此前未通信时延也只有100毫秒，是TCP+TLS用时的1/3）。此外，QUIC还增加了拥塞控制和自动重传等功能，所以可靠性上要比UDP更高。</p><p>从目标上看，QUIC跟SPDY（HTTP/2基础）很多方面是类似的，但是后者仍然基于TCP，所以仍然会存在部分相同的时延问题。</p><p>为什么不干脆改进TCP，因为TCP往往直接内置到了操作系统内核当中。</p><p><img src="https://ws1.sinaimg.cn/large/73d640f7gy1ftl9uru2trj20m80bydgn.jpg" alt="image"></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;&lt;p&gt;源自于一道面试题，面试官问我是否了解高性能UDP&lt;/p&gt;&lt;/blockquote&gt;&lt;h2 id=&quot;基本概念&quot;&gt;&lt;a href=&quot;#基本概念&quot; class=&quot;headerlink&quot; title=&quot;基本概念&quot;&gt;&lt;/a&gt;基本概念&lt;/h2&gt;&lt;p&gt;QUIC是Quick UDP Internet Connection的简称，是Google制定的一种基于UDP的低时延的互联网传输层协议。TCP/IP协议族是互联网的基础。其中传输层协议包括TCP和UDP协议。与TCP协议相比，UDP更为轻量，但是错误校验也要少得多。这意味着UDP往往效率更高（不经常跟服务器端通信查看数据包是否送达或者按序），但是可靠性比不上TCP。通常游戏、流媒体以及VoIP等应用均采用UDP，而网页、邮件、远程登录等大部分的应用均采用TCP。&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/JasonRen23/imgs/master/QUIC-Figure-1.png&quot; alt=&quot;网络分层&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="计算机网络" scheme="https://jasonren.top/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
      <category term="TCP/UDP" scheme="https://jasonren.top/tags/TCP-UDP/"/>
    
  </entry>
  
  <entry>
    <title>Java内存区域</title>
    <link href="https://jasonren.top/2018/04/08/java%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F/"/>
    <id>https://jasonren.top/2018/04/08/java内存区域/</id>
    <published>2018-04-07T16:00:00.000Z</published>
    <updated>2018-11-22T07:51:49.931Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>Java与C++之间有一堵由内存动态分配和垃圾收集技术所围成的“高墙”，墙外面的人想进去，墙里面的人却想出来。</p></blockquote><p>Java虚拟机在执行Java程序的过程中会把它管理的内存划分为若干个不同的数据区域。</p><p><img src="https://ws1.sinaimg.cn/large/73d640f7gy1ftl9vw5caej20o20g7q5e.jpg" alt="JVM内存结构"></p><a id="more"></a><h2 id="程序计数器（Program-Counter-Register）"><a href="#程序计数器（Program-Counter-Register）" class="headerlink" title="程序计数器（Program Counter Register）"></a>程序计数器（Program Counter Register）</h2><ul><li>线程私有</li></ul><p>程序计数器是一块较小的内存空间，可以看作是当前线程所执行的字节码的<strong>行号指示器</strong>。在虚拟机概念模型中，<strong>字节码解释器</strong>工作时就是通过改变计数器的值来选取下一条需要执行的字节码指令，分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖这个计数器来完成。</p><p>程序计数器是一块“<strong>线程私有</strong>”的内存，如上文的图所示，每条线程都有一个独立的程序计数器，各条线程之间的计数器互不影响，独立存储。<strong>注意，Java虚拟机中的程序计数器指向正在执行的字节码地址，而不是下一条</strong>。这样设计使得在多线程环境下，线程切换后能恢复到正确的执行位置。</p><p>如果线程正在执行的是一个<strong>Java方法</strong>，这个计数器记录的是正在执行的<strong>虚拟机字节码指令的地址</strong>；若执行的是<strong>Native方法</strong>，则<strong>计数器为空（Undefined）</strong>（因为对于Native方法而言，它的方法体并不是由Java字节码构成的，自然无法应用上述的“字节码指令的地址”的概念）。程序计数器也是唯一一个在Java虚拟机规范中没有规定任何<strong>OutOfMemoryError</strong>情况的内存区域。</p><h2 id="Java虚拟机栈（Java-Virtual-Machine-Stacks）"><a href="#Java虚拟机栈（Java-Virtual-Machine-Stacks）" class="headerlink" title="Java虚拟机栈（Java Virtual Machine Stacks）"></a>Java虚拟机栈（Java Virtual Machine Stacks）</h2><ul><li>线程私有</li><li>生命周期和线程相同</li><li>StackOverflowError</li><li>OutOfMemoryError</li></ul><p><strong>Java虚拟机栈（Java Virtual Machine Stacks</strong>）描述的是<strong>Java方法执行的内存模型</strong>：每个方法在执行的同时都会创建一个<strong>栈帧（Stack Frame）</strong>，栈帧中存储着<strong>局部变量表、操作数栈、动态链接、方法出口</strong>等信息。<strong>每一个方法从调用直至执行完成的过程</strong>，<strong>会对应一个栈帧在虚拟机栈中入栈到出栈的过程</strong>。与程序计数器一样，Java虚拟机栈也是<strong>线程私有</strong>的。</p><p>函数的调用有完美的嵌套关系——调用者的生命期总是长于被调用者的生命期，并且后者在前者的之内。这样，被调用者的局部信息所占空间的分配总是后于调用者的（后入），而其释放则总是先于调用者的（先出），所以正好可以满足栈的LIFO顺序，选用栈这种数据结构来实现调用栈是一种很自然的选择。</p><p><strong>局部变量表</strong>中存放了编译期可知的各种：</p><ul><li><strong>基本数据类型</strong>(boolen、byte、char、short、int、 float、 long、double）</li><li><strong>对象引用</strong>（reference类型，它不等于对象本身，可能是一个指向对象起始地址的指针，也可能是指向一个代表对象的句柄或其他与此对象相关的位置）</li><li><strong>returnAddress类型</strong>（指向了一条字节码指令的地址）</li></ul><p>其中64位长度的long和double类型的数据会占用2个局部变量空间（Slot），其余数据类型只占用1个。<strong>局部变量表所需的内存空间在编译期间完成分配</strong>，当进入一个方法时，这个方法需要在帧中分配多大的局部变量空间是完全确定的，在方法运行期间不会改变局部变量表的大小。</p><p>Java虚拟机规范中对这个区域规定了两种异常状况：</p><ul><li><strong>StackOverflowError</strong>：线程请求的栈深度大于虚拟机所允许的深度，将会抛出此异常。</li><li><strong>OutOfMemoryError</strong>：当可动态扩展的虚拟机栈在扩展时无法申请到足够的内存，就会抛出该异常。</li></ul><h2 id="本地方法栈（Native-Method-Stack）"><a href="#本地方法栈（Native-Method-Stack）" class="headerlink" title="本地方法栈（Native Method Stack）"></a>本地方法栈（Native Method Stack）</h2><p><strong>本地方法栈（Native Method Stack</strong>）与Java虚拟机栈作用很相似，它们的区别在于虚拟机栈为虚拟机执行Java方法（即字节码）服务，而本地方法栈则为虚拟机使用到的Native方法服务。</p><p>在虚拟机规范中对本地方法栈中使用的语言、方式和数据结构并无强制规定，因此具体的虚拟机可实现它。甚至<strong>有的虚拟机（Sun HotSpot虚拟机）直接把本地方法栈和虚拟机栈合二为一</strong>。与虚拟机栈一样，本地方法栈会抛出<strong>StackOverflowErro</strong>r和<strong>OutOfMemoryError</strong>异常。</p><h2 id="Java堆（Heap）"><a href="#Java堆（Heap）" class="headerlink" title="Java堆（Heap）"></a>Java堆（Heap）</h2><ul><li>所占空间大</li><li>线程共享</li><li>OutOfMemoryError</li></ul><p>Java堆是被所有的<strong>线程共享</strong>的一块内存区域，在虚拟机启动时创建。<br>Java堆的唯一目的就是存放对象实例，<strong>几乎所有</strong>的<strong>对象实例</strong>都在这里分配内存，且每次分配的空间是<strong>不定长</strong>的。在Heap 中分配一定的内存来保存对象实例，实际上只是保存<strong>对象实例的属性值，属性的类型和对象本身的类型标记</strong>等，<strong>并不保存对象的方法（方法是指令，保存在Stack中）</strong>，在Heap 中分配一定的内存保存对象实例和对象的序列化比较类似。对象实例在Heap 中分配好以后，需要在<strong>Stack中保存一个4字节的Heap 内存地址</strong>，用来定位该对象实例在Heap 中的位置，便于找到该对象实例。</p><p>Java堆是垃圾回收器管理的主要区域，因此也被称为”<strong>GC堆</strong>“。<br>从内存回收的角度看，由于现在收集器基本都采用分代收集算法，所以Java堆可以细分为：新生代、老生代；</p><p><img src="https://pic.yupoo.com/crowhawk/5cf46998/fe5079d3.png" alt="内存空间划分"></p><ul><li><strong>新生代（Young）</strong>： 新生成的对象优先存放在新生代中，新生代对象朝生夕死，存活率很低。在新生代中，常规应用进行一次垃圾收集一般可以回收70% ~ 95% 的空间，回收效率很高。新生代又可细分为<strong>Eden空间</strong>、<strong>From Survivor空间</strong>、<strong>To Survivor空间</strong>，默认比例为8:1:1。它们的具体作用将在下一篇文章讲解GC时介绍。</li><li><strong>老年代（Tenured/Old）</strong>：在新生代中经历了多次（具体看虚拟机配置的阀值）GC后仍然存活下来的对象会进入老年代中。老年代中的对象生命周期较长，存活率比较高，在老年代中进行GC的频率相对而言较低，而且回收的速度也比较慢。</li><li><strong>永久代（Perm）</strong>：永久代存储类信息、常量、静态变量、即时编译器编译后的代码等数据，对这一区域而言，Java虚拟机规范指出可以不进行垃圾收集，一般而言不会进行垃圾回收。</li></ul><p>其中<strong>新生代和老年代组成了Java堆的全部内存区域</strong>，而<strong>永久代不属于堆空间，它在JDK 1.8以前被Sun HotSpot虚拟机用作方法区的实现</strong>，关于方法区的具体内容将在稍后介绍。</p><p>从内存分配的角度看，线程共享的Java堆可能划分出多个线程私有的分配缓冲区（TLAB）；<br>不论如何划分，都与存放的内容无关，无论哪个区域，存储的仍然是对象实例。</p><p>Java虚拟机规范规定，Java堆可以处于<strong>物理上不连续</strong>的内存空间中，只要<strong>逻辑上是连续</strong>的即可，就像我们的磁盘空间一样。在实现上，既可以是固定大小的，也可以是可扩展的，不过当前主流JVM都是按照可扩展来实现的。</p><p>Java虚拟机规范规定，如果在堆上没有内存完成实例分配，并且堆上也无法再扩展时，将会抛出<code>OutOfMemoryError</code>异常。</p><p><strong>内存泄露和内存溢出</strong><br><br>Java堆内存的OOM异常是非常常见的异常情况，重点是根据内存中的对象是否是必要的，来弄清楚到底是出现了内存泄露(Memory Leak)还是内存溢出(Memory Overflow)。</p><ul><li>内存泄露：指程序中一些对象不会被GC所回收，它始终占用内存，即被分配的对象引用链可达但已无用。（可用内存减少）</li><li>内存溢出：程序运行过程中无法申请到足够的内存而导致的一种错误。内存溢出通常发生于OLD段或Perm段垃圾回收后，仍然无内存空间容纳新的Java对象的情况。<br>内存泄露是内存溢出的一种诱因，不是唯一因素。</li></ul><h2 id="方法区（Method-Area）"><a href="#方法区（Method-Area）" class="headerlink" title="方法区（Method Area）"></a>方法区（Method Area）</h2><p><strong>方法区（Method Area）</strong>与Java堆一样，是各个线程共享的内存区域。用于存储已被虚拟机加载的<strong>类信息、常量、静态变量、JIT编译后的代码</strong>也存储在方法区。正因为方法区所存储的数据与堆有一种类比关系，所以它还被称为 <strong>Non-Heap</strong>。</p><p><strong>JDK 1.8以前的永久代（PermGen）</strong></p><p>Java虚拟机规范对方法区的限制非常宽松，除了和Java堆一样不需要连续的内存和可以选择固定大小或者可扩展外，还可以选择不实现垃圾收集，也就是说，Java虚拟机规范只是规定了方法区的概念和它的作用，并没有规定如何去实现它。<strong>对于JDK 1.8之前的版本，HotSpot虚拟机设计团队选择把GC分代收集扩展至方法区，即用永久代来实现方法区</strong>，这样HotSpot的垃圾收集器可以像管理Java堆一样管理这部分内存，能够省去专门为方法区编写内存管理代码的工作。对于其他的虚拟机（如<strong>Oracle JRockit、IBM J9</strong>等）来说是不存在永久代的概念的。</p><p>如果运行时有大量的类产生，可能会导致方法区被填满，直至溢出。常见的应用场景如：</p><ul><li>Spring和ORM框架使用CGLib操纵字节码对类进行增强，增强的类越多，就需要越大的方法区来保证动态生成的Class可以加载入内存。</li><li>大量JSP或动态产生JSP文件的应用（JSP第一次运行时需要编译为Java类）。</li><li>基于OSGi的应用（即使是同一个类文件，被不同的类加载器加载也会视为不同的类）。 ……<br>这些都会导致方法区溢出，报出<code>java.lang.OutOfMemoryError: PermGen space</code>。</li></ul><p><strong>JDK 1.8的元空间（Metaspace）</strong></p><p>在JDK 1.8中，HotSpot虚拟机设计团队为了促进<strong>HotSpot</strong>与 <strong>JRockit</strong>的融合，修改了方法区的实现，移除了永久代，选择使用<strong>本地化的内存空间</strong>（而不是JVM的内存空间）存放类的元数据，这个空间叫做<strong>元空间（Metaspace</strong>）。</p><p>做了这个改动以后，<code>java.lang.OutOfMemoryError: PermGen</code>的空间问题将不复存在，并且不再需要调整和监控这个内存空间。且虚拟机需要为方法区设计额外的GC策略：如果类元数据的空间占用达到参数“<strong>MaxMetaspaceSize</strong>”设置的值，将会触发对死亡对象和类加载器的垃圾回收。 为了限制垃圾回收的频率和延迟，适当的监控和调优<strong>元空间</strong>是非常有必要的。元空间过多的垃圾收集可能表示类、类加载器内存泄漏或对你的应用程序来说空间太小了。</p><p>元空间的内存管理由<strong>元空间虚拟机</strong>来完成。先前，对于类的元数据我们需要不同的垃圾回收器进行处理，现在只需要执行元空间虚拟机的C++代码即可完成。<strong>在元空间中，类和其元数据的生命周期和其对应的类加载器</strong>是相同的。换句话说，<strong>只要类加载器存活，其加载的类的元数据也是存活的</strong>，因而不会被回收掉。</p><p>我们从行文到现在提到的元空间稍微有点不严谨。准确的来说，<strong>每一个类加载器的存储区域都称作一个元空间，所有的元空间合在一起就是我们一直说的元空间</strong>。当一个类加载器被垃圾回收器标记为不再存活，其对应的元空间会被回收。在元空间的回收过程中没有重定位和压缩等操作。但是元空间内的元数据会进行扫描来确定Java引用。</p><p><strong>元空间虚拟机</strong>负责元空间的分配，其采用的形式为<strong>组块分配</strong>。组块的大小因类加载器的类型而异。在元空间虚拟机中存在一个<strong>全局的空闲组块列表</strong>。当一个类加载器需要组块时，它就会从这个全局的组块列表中获取并维持一个自己的组块列表。当一个类加载器不再存活，那么其持有的组块将会被释放，并返回给全局组块列表。类加载器持有的组块又会被分成多个块，每一个块存储一个单元的元信息。组块中的块是<strong>线性分配（指针碰撞分配形式）</strong>。组块分配自内存映射区域。这些全局的虚拟内存映射区域以链表形式连接，一旦某个虚拟内存映射区域清空，这部分内存就会返回给操作系统。</p><p><img src="https://pic.yupoo.com/crowhawk/cdaea117/7bdf00c4.png" alt="元组块的分配"></p><p>上图展示的是虚拟内存映射区域如何进行元组块的分配。类加载器1和3表明使用了反射或者为匿名类加载器，他们使用了特定大小组块。 而类加载器2和4根据其内部条目的数量使用小型或者中型的组块。</p><h3 id="运行时常量池（Runtime-Constant-Pool）"><a href="#运行时常量池（Runtime-Constant-Pool）" class="headerlink" title="运行时常量池（Runtime Constant Pool）"></a>运行时常量池（Runtime Constant Pool）</h3><p><strong>运行时常量池（Runtime Constant Pool）</strong> 是方法区的一部分。 <strong>Class文件</strong> 中除了有类的版本、字段、方法、接口等描述信息外，还有一项信息是 <strong>常量池（Constant Pool Table）</strong>，用于存放编译期生成的各种字面量和符号引用，<strong>这部分内容将在类加载后进入方法区的运行时常量池存放</strong>。</p><p>Java虚拟机对Class文件每一部分（自然包括常量池）的格式有严格规定，每一个字节用于存储那种数据都必须符合规范上的要求才会被虚拟机认可、装载和执行。但<strong>对于运行时常量池，Java虚拟机规范没有做任何有关细节的要求</strong>，不同的提供商实现的虚拟机可以按照自己的需求来实现此内存区域。不过一般而言，除了保存<strong>Class文件中的描述符号引用</strong>外，还会把<strong>翻译出的直接引用</strong>也存储在运行时常量池中。</p><p>运行时常量池相对于Class文件常量池的另外一个重要特征是具备<strong>动态性</strong>，Java语言并不要求常量一定只有编译器才能产生，也就是<strong>并非置入Class文件中的常量池的内容才能进入方法区运行时常量池，运行期间也可能将新的常量放入池中</strong>，此特性被开发人员利用得比较多的便是String类的<code>intern()</code>方法。</p><p><code>String.intern()</code>是一个Native方法，它的作用是：如果字符串常量池中已经包含了一个等于此String对象的字符串，则返回代表池中这个字符串的String对象；否则，将此String对象包含的字符串添加到常量池中，并且返回此字符串的引用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123; </span><br><span class="line">   String str1 = <span class="keyword">new</span> StringBuilder(<span class="string">"计算机"</span>).append(<span class="string">"软件"</span>).toString();</span><br><span class="line">   System.out.println(str1.intern() == str1);</span><br><span class="line">   </span><br><span class="line">   String str2 = <span class="keyword">new</span> StringBuilder(<span class="string">"ja"</span>).append(<span class="string">"va"</span>).toString();</span><br><span class="line">   System.out.println(str2.intern() == str2);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>这段代码在JDK1.6中运行，会得到两个false，而在JDK1.7中运行，会得到一个true和一个false。原因是：</p><ul><li>在JDK1.6中<code>intern()</code>方法会把首次遇到的字符串实例复制到永久代中，返回的也是永久代中这个字符串实例的引用，而由StringBuilder创建的字符串实例在Java堆上，所以必然不是一个引用。</li><li>在JDK1.7中<code>intern()</code>方法不会复制实例，只是在常量池中记录首次出现的实例引用，因此<code>intern()</code>返回的引用和由StringBuilder创建的字符串实例是同一个。</li><li>str2返回false是因为Java这个字符串在执行 <code>StringBuilder(&quot;ja&quot;).append(&quot;va&quot;).toString()</code>之前已经出现过，字符串常量池中已经有它的引用了，不符合首次出现的原则，而<code>&quot;计算机软件&quot;</code>这个字符串是首次出现的。</li></ul><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ol><li><a href="https://crowhawk.github.io/2017/08/09/jvm_1/" target="_blank" rel="noopener">《深入理解Java虚拟机——JVM高级特性与最佳实践》－周志明</a></li><li><a href="https://crowhawk.github.io/2017/08/09/jvm_1/" target="_blank" rel="noopener">crowhawk.github.io</a></li><li><a href="https://www.jianshu.com/p/7ebbe102c1ae" target="_blank" rel="noopener">梦工厂简书博客</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;&lt;p&gt;Java与C++之间有一堵由内存动态分配和垃圾收集技术所围成的“高墙”，墙外面的人想进去，墙里面的人却想出来。&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;Java虚拟机在执行Java程序的过程中会把它管理的内存划分为若干个不同的数据区域。&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;https://ws1.sinaimg.cn/large/73d640f7gy1ftl9vw5caej20o20g7q5e.jpg&quot; alt=&quot;JVM内存结构&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Java" scheme="https://jasonren.top/categories/Java/"/>
    
    
      <category term="JVM" scheme="https://jasonren.top/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>Kubernetes部署指南</title>
    <link href="https://jasonren.top/2018/03/08/Kubernetes/"/>
    <id>https://jasonren.top/2018/03/08/Kubernetes/</id>
    <published>2018-03-07T16:00:00.000Z</published>
    <updated>2018-11-22T07:51:49.930Z</updated>
    
    <content type="html"><![CDATA[<p>最近忙于面试，为了缓解紧张的备战心情，更新一下之前总结的一些关于k8s的部署指南，包括<strong>单机版</strong>和<strong>集群版</strong>。<br><img src="https://ws1.sinaimg.cn/large/73d640f7gy1ftl9vxtsxvj20wp0fkdmx.jpg" alt=""><br><a id="more"></a></p><h2 id="单机版-kubernetes"><a href="#单机版-kubernetes" class="headerlink" title="单机版 kubernetes"></a>单机版 kubernetes</h2><p>即 Master 和 Node （Minion）为同一台机器<br></p><p>关闭防火墙<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">systemctl <span class="built_in">disable</span> firewalld.service</span><br><span class="line">systemctl stop firewalld.service</span><br></pre></td></tr></table></figure><p></p><p>安装启用 iptabels<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">yum install -y iptables-services</span><br><span class="line">systemctl <span class="built_in">enable</span> iptables.service</span><br><span class="line">systemctl start iptables.service</span><br></pre></td></tr></table></figure><p></p><p>配置 kubernetes yum 源<br></p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">vim</span> /etc/yum.repos.d/kubernetes.repo</span><br><span class="line"></span><br><span class="line">[kubernetes]</span><br><span class="line">name=Kubernetes</span><br><span class="line">baseurl=http://yum.kubernetes.io/repos/kubernetes-el7-x86_64</span><br><span class="line">enabled=<span class="number">1</span></span><br><span class="line">gpgcheck=<span class="number">0</span></span><br><span class="line">repo_gpgcheck=<span class="number">1</span></span><br><span class="line">gpgkey=http<span class="variable">s:</span>//packages.cloud.google.<span class="keyword">com</span>/yum/doc/yum-key.gpg</span><br><span class="line">http<span class="variable">s:</span>//packages.cloud.google.<span class="keyword">com</span>/yum/doc/rpm-package-key.gpg</span><br></pre></td></tr></table></figure><p></p><p>安装etcd 和k8s<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install -y etcd kubernetes</span><br></pre></td></tr></table></figure><p></p><p>安装过程中会安装 docker，为了防止与已有 docker 版本冲突，安装之前最好卸载掉已有的 docker。<br>修改配置文件</p><ul><li>Docker 配置文件 /etc/sysconfig/docker<br><code>vim /etc/sysconfig/docker</code><br><br>其中的OPTIONS的内容设置为如下<br><code>OPTIONS=&#39;--selinux-enabled=false --insecure-registry gcr.io&#39;</code></li><li><p>apiserver 配置文件 /etc/kubernetes/apiserver<br><code>vim /etc/kubernetes/apiserver</code><br><br>删除 KUBE_ADMISSION_CONTROL 中的 ServiceAccount</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">KUBE_ADMISSION_CONTROL=<span class="string">"--admission_control=NamespaceLifecycle,NamespaceExists,LimitRanger,SecurityContextDeny,ServiceAccount,ResourceQuota"</span></span><br></pre></td></tr></table></figure></li><li><p>改为：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">KUBE_ADMISSION_CONTROL=<span class="string">"--admission_control=NamespaceLifecycle,NamespaceExists,LimitRanger,SecurityContextDeny,ResourceQuota"</span></span><br></pre></td></tr></table></figure></li></ul><p>按照顺序启动服务<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">systemctl start etcd</span><br><span class="line">systemctl start docker</span><br><span class="line">systemctl start kube-apiserver.service</span><br><span class="line">systemctl start kube-controller-manager.service</span><br><span class="line">systemctl start kube-scheduler.service</span><br><span class="line">systemctl start kubelet.service</span><br><span class="line">systemctl start kube-proxy.service</span><br></pre></td></tr></table></figure><p></p><h2 id="单机版k8s的小例子"><a href="#单机版k8s的小例子" class="headerlink" title="单机版k8s的小例子"></a>单机版k8s的小例子</h2><p>以上步骤完成了单机版 kubernetes 的安装启动，以下为一个简单的小例子来测试运行。</p><h3 id="启动-MySQL-容器服务"><a href="#启动-MySQL-容器服务" class="headerlink" title="启动 MySQL 容器服务"></a>启动 MySQL 容器服务</h3><ul><li>先拉取所需的 docker image 方便 rc 进行 pod 创建时使用<br><code>docker pull mysql</code></li><li><p>创建文件 mysql-rc.yaml</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">ReplicationController</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"><span class="attr">  name:</span> <span class="string">mysql</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line"><span class="attr">  replicas:</span> <span class="number">1</span></span><br><span class="line"><span class="attr">  selector:</span></span><br><span class="line"><span class="attr">    app:</span> <span class="string">mysql</span></span><br><span class="line"><span class="attr">  template:</span></span><br><span class="line"><span class="attr">    metadata:</span></span><br><span class="line"><span class="attr">      labels:</span></span><br><span class="line"><span class="attr">        app:</span> <span class="string">mysql</span></span><br><span class="line"><span class="attr">    spec:</span></span><br><span class="line"><span class="attr">      containers:</span></span><br><span class="line"><span class="attr">      - name:</span> <span class="string">mysql</span></span><br><span class="line"><span class="attr">        image:</span> <span class="string">mysql</span></span><br><span class="line"><span class="attr">        ports:</span></span><br><span class="line"><span class="attr">        - containerPort:</span> <span class="number">3306</span></span><br><span class="line"><span class="attr">        env:</span></span><br><span class="line"><span class="attr">        - name:</span> <span class="string">MYSQL_ROOT_PASSWORD</span></span><br><span class="line"><span class="attr">          value:</span> <span class="string">"123456"</span></span><br></pre></td></tr></table></figure></li><li><p>创建 rc</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl create -f mysql-rc.yaml</span><br><span class="line">replicationcontroller <span class="string">'mysql'</span> created</span><br></pre></td></tr></table></figure></li><li><p>查看 rc</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl get rc</span><br><span class="line">NAME DESIRED CURRENT READY AGE</span><br><span class="line">mysql 1 1 0 14s</span><br></pre></td></tr></table></figure></li><li><p>查看 pod</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl get pods</span><br><span class="line">NAME READY STATUS RESTARTS AGE</span><br><span class="line">mysql-b0gk0 0/1 ContainerCreating 0 3s</span><br></pre></td></tr></table></figure></li><li><p>此时pod 的状态处于 ContainerCreating，需要等待一下，直到状态变为Running</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">NAME READY STATUS RESTARTS AGE</span><br><span class="line">mysql-b0gk0 1/1 Running 0 6m</span><br></pre></td></tr></table></figure></li><li><p>创建文件 mysql-svc.yaml</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Service</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"><span class="attr">  name:</span> <span class="string">mysql</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line"><span class="attr">  ports:</span></span><br><span class="line"><span class="attr">    - port:</span> <span class="number">3306</span></span><br><span class="line"><span class="attr">  selector:</span></span><br><span class="line"><span class="attr">    app:</span> <span class="string">mysql</span></span><br></pre></td></tr></table></figure></li><li><p>创建 service</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl create -f mysql-svc.yaml</span><br><span class="line">service <span class="string">"mysql"</span> created</span><br></pre></td></tr></table></figure></li><li><p>查看service状态</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl get svc</span><br><span class="line">NAME CLUSTER-IP EXTERNAL-IP PORT(S) AGE</span><br><span class="line">kubernetes 10.254.0.1 &lt;none&gt; 443/TCP 18m</span><br><span class="line">mysql 10.254.185.20 &lt;none&gt; 3306/TCP 14s</span><br></pre></td></tr></table></figure></li><li><p><strong>注意到MySQL服务被分配了一个值为 10.254.185.20 的 CLUSTER-IP，这是一个虚地址，随后，Kubernetes 集群中的其他新创建的 Pod 就可以通过Service 的 CLUSTER-IP + 端口 6379 来连接和访问它了。</strong></p></li></ul><h3 id="启动-Web-容器服务"><a href="#启动-Web-容器服务" class="headerlink" title="启动 Web 容器服务"></a>启动 Web 容器服务</h3><ul><li>先拉取所需的 docker image 方便 rc 进行 pod 创建时使用<br><code>docker pull kubeguide/tomcat-app:v1</code></li><li><p>创建文件 myweb-rc.yaml</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">ReplicationController</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"><span class="attr">  name:</span> <span class="string">myweb</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line"><span class="attr">  replicas:</span> <span class="number">1</span></span><br><span class="line"><span class="attr">  selector:</span></span><br><span class="line"><span class="attr">    app:</span> <span class="string">myweb</span></span><br><span class="line"><span class="attr">  template:</span></span><br><span class="line"><span class="attr">    metadata:</span></span><br><span class="line"><span class="attr">      labels:</span></span><br><span class="line"><span class="attr">        app:</span> <span class="string">myweb</span></span><br><span class="line"><span class="attr">    spec:</span></span><br><span class="line"><span class="attr">      containers:</span></span><br><span class="line"><span class="attr">        - name:</span> <span class="string">myweb</span></span><br><span class="line"><span class="attr">          image:</span> <span class="string">kubeguide/tomcat-app:v1</span></span><br><span class="line"><span class="attr">          ports:</span></span><br><span class="line"><span class="attr">          - containerPort:</span> <span class="number">8080</span></span><br></pre></td></tr></table></figure></li><li><p>创建rc</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl create -f myweb-rc.yaml</span><br><span class="line">replicationcontroller <span class="string">"myweb"</span> created</span><br></pre></td></tr></table></figure></li><li><p>查看rc</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl get rc</span><br><span class="line">NAME DESIRED CURRENT READY AGE</span><br><span class="line">mysql 1 1 1 43m</span><br><span class="line">myweb 5 5 0 21s</span><br></pre></td></tr></table></figure></li><li><p>查看 pod，根据 rc 中的设置，有 5 个 replicas</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl get pods</span><br><span class="line">NAME READY STATUS RESTARTS AGE</span><br><span class="line">mysql-wk349 1/1 Running 0 44m</span><br><span class="line">myweb-dlfwg 1/1 Running 0 58s</span><br><span class="line">myweb-m0j9c 1/1 Running 0 58s</span><br><span class="line">myweb-tss55 1/1 Running 0 58s</span><br><span class="line">myweb-v9p21 1/1 Running 0 58s</span><br><span class="line">myweb-w5bs4 1/1 Running 0 58s</span><br></pre></td></tr></table></figure></li><li><p>创建文件myweb-svc.yaml</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Service</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"><span class="attr">  name:</span> <span class="string">myweb</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line"><span class="attr">  type:</span> <span class="string">NodePort</span></span><br><span class="line"><span class="attr">  ports:</span></span><br><span class="line"><span class="attr">    - port:</span> <span class="number">8080</span></span><br><span class="line"><span class="attr">      nodePort:</span> <span class="number">30001</span></span><br><span class="line"><span class="attr">  selector:</span></span><br><span class="line"><span class="attr">    app:</span> <span class="string">myweb</span></span><br></pre></td></tr></table></figure></li><li><p>创建service</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl create -f myweb-svc.yaml</span><br><span class="line">service <span class="string">"myweb"</span> created</span><br></pre></td></tr></table></figure></li><li><p>查看 service</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl get services</span><br><span class="line">NAME CLUSTER-IP EXTERNAL-IP PORT(S) AGE</span><br><span class="line">kubernetes 10.254.0.1 &lt;none&gt; 443/TCP 5h</span><br><span class="line">mysql 10.254.201.141 &lt;none&gt; 3306/TCP 45m</span><br><span class="line">myweb 10.254.90.94 &lt;nodes&gt; 8080:30001/TCP 23s</span><br></pre></td></tr></table></figure></li></ul><p><strong>至此，完成了一个简单的 kubernetes 单机版例子，可以在浏览器输入 <a href="http://ip:30001/demo/" target="_blank" rel="noopener">http://ip:30001/demo/</a> 来测试发布的web应用</strong></p><h2 id="多-Node（Minion）的-kubernetes-cluster"><a href="#多-Node（Minion）的-kubernetes-cluster" class="headerlink" title="多 Node（Minion）的 kubernetes cluster"></a>多 Node（Minion）的 kubernetes cluster</h2><p>为上述单机版的添加一个新的 node。<br>以下没有特别说明的时候，都是在 node 上进行的操作。</p><p>关闭防火墙<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">systemctl <span class="built_in">disable</span> firewalld.service</span><br><span class="line">systemctl stop firewalld.service</span><br></pre></td></tr></table></figure><p></p><p>安装启用 iptabels<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">yum install -y iptables-services</span><br><span class="line">systemctl start iptables.service</span><br><span class="line">systemctl <span class="built_in">enable</span> iptables.service</span><br></pre></td></tr></table></figure><p></p><p>配置 yum 源<br></p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">vim</span> /etc/yum.repos.d/kubernetes.repo</span><br><span class="line"></span><br><span class="line">[kubernetes]</span><br><span class="line">name=Kubernetes</span><br><span class="line">baseurl=http://yum.kubernetes.io/repos/kubernetes-el7-x86_64</span><br><span class="line">enabled=<span class="number">1</span></span><br><span class="line">gpgcheck=<span class="number">0</span></span><br><span class="line">repo_gpgcheck=<span class="number">1</span></span><br><span class="line">gpgkey=http<span class="variable">s:</span>//packages.cloud.google.<span class="keyword">com</span>/yum/doc/yum-key.gpg</span><br><span class="line">http<span class="variable">s:</span>//packages.cloud.google.<span class="keyword">com</span>/yum/doc/rpm-package-key.gpg</span><br></pre></td></tr></table></figure><p></p><p>安装 kubernetes<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install -y kubernetes</span><br></pre></td></tr></table></figure><p></p><ul><li><strong>安装过程中会安装 docker，为了防止与已有 docker 版本冲突，安装之前最好卸载掉已有的 docker</strong></li><li><strong>与 Master 不同，Node 不用安装 etcd，在后面配置中指向 Master 的 etcd server 即可</strong><br></li></ul><p>修改配置文件</p><ul><li><p>Master 上<br>修改配置 Master 和 etcd server 信息</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/kubernetes/config</span><br><span class="line">KUBE_MASTER=<span class="string">"--master=http://10.75.12.117:8080"</span></span><br><span class="line">KUBE_ETCD_SERVERS=<span class="string">"--etcd-servers=http://10.75.12.117:2379"</span></span><br></pre></td></tr></table></figure></li><li><p>默认值是 127.0.0.1 ，换成 Master 的具体 IP，与 /etc/etcd/etcd.conf 中的设置一致<br><br><code>ETCD_LISTEN_CLIENT_URLS=&quot;http://10.75.12.117:2379&quot;</code><br></p></li><li><p>如果有修改 etcd.conf 要重启 etcd， <code>systemctl restart etcd</code></p></li><li><p>修改配置 api server 信息</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/kubernetes/apiserver</span><br><span class="line">KUBE_API_ADDRESS=<span class="string">"--insecure-bind-address=0.0.0.0"</span></span><br><span class="line">KUBE_API_PORT=<span class="string">"--port=8080"</span></span><br><span class="line"><span class="comment"># KUBE_ETCD_SERVERS="--etcd-servers=http://127.0.0.1:2379"</span></span><br></pre></td></tr></table></figure></li><li><p>注释掉 KUBE_ETCD_SERVERS，config 中已经设置过了</p></li><li><p>重启 Master 服务</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">systemctl restart etcd</span><br><span class="line">systemctl restart kube-apiserver.service</span><br><span class="line">systemctl restart kube-controller-manager.service</span><br><span class="line">systemctl restart kube-scheduler.service</span><br></pre></td></tr></table></figure></li><li><p>Node 上<br>单机版的 Master 作为 Node 时，配置文件修改方式和单独作为 Node 节点的配置文件修改一样。</p></li><li><p>设置指向 Master 和 etcd server</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">vim</span> /etc/kubernetes/config</span><br><span class="line">KUBE_MASTER=<span class="string">"--master=http://10.75.12.117:8080"</span></span><br><span class="line">KUBE_ETCD_SERVERS=<span class="string">"--etcd-servers=http://10.75.12.117:2379"</span></span><br><span class="line"><span class="number">10.75</span>.<span class="number">12.117</span> 为 Master IP</span><br></pre></td></tr></table></figure></li><li><p>修改 kubelet</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">vim</span> /etc/kubernetes/kubelet</span><br><span class="line">KUBELET_ADDRESS=<span class="string">"--address=0.0.0.0"</span></span><br><span class="line">KUBELET_PORT=<span class="string">"--port=10250"</span></span><br><span class="line">KUBELET_HOSTNAME=<span class="string">"--hostname-override=10.75.12.120"</span> </span><br><span class="line">KUBELET_API_SERVER=<span class="string">"--api-servers=http://10.75.12.117:8080"</span></span><br></pre></td></tr></table></figure></li><li><p>KUBELET_HOSTNAME 为具体的当前 node hostname/IP， 确保是能够解析的 hostname，否则找不到是不能向 Master 注册 Node 的。<br></p><p>启动 Node 的服务</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">systemctl start docker</span><br><span class="line">systemctl start kubelet.service</span><br><span class="line">systemctl start kube-proxy.service</span><br></pre></td></tr></table></figure><p>在<code>/var/log/messages</code> 中提取查看 kube 的信息，可以看到 Node 向 Master 注册自己。<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Aug  2 21:55:28 localhost kubelet: I0802 21:55:28.449019   24104 kubelet_node_status.go:77] Successfully registered node 10.75.12.120</span><br></pre></td></tr></table></figure><p></p><p>在 Master 上查看 Node，可以看到新注册进去的 Node。<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl get nodes</span><br><span class="line">NAME STATUS AGE</span><br><span class="line">127.0.0.1 NotReady 2m</span><br><span class="line">10.75.12.120 Ready 5m</span><br><span class="line">10.75.12.117 Ready 6m</span><br></pre></td></tr></table></figure><p></p><p><code>10.75.12.120</code> 是新添加的 node，<code>10.75.12.117</code> 是 Master 上进行修改添加的 node，所以原来的 <code>127.0.0.1</code>被替换注册后，处于<code>NotReady</code>状态。</p><p><strong>如果出现 node 注册失败，请检查 Master 和 node 网络是否联通，iptables 的设置中是否有相应的 rule 进行阻拦。</strong></p><h2 id="rc-创建-pod-时访问-private-registry-获取-docker-image"><a href="#rc-创建-pod-时访问-private-registry-获取-docker-image" class="headerlink" title="rc 创建 pod 时访问 private registry 获取 docker image"></a>rc 创建 pod 时访问 private registry 获取 docker image</h2><p>非 public registry 获取 docker image 时，需要使用 <code>Secret</code></p><ul><li><p>创建 Secret<br>使用 kubectl create secret 命令创建 secret，指定 private registry 名称，对应的访问地址，以及访问使用的用户名和密码，最后是邮箱<br><code>kubectl create secret docker-registry regsecret --docker-server=&lt;your-registry-server&gt; --docker-username=&lt;your-name&gt; --docker-password=&lt;your-pword&gt; --docker-email=&lt;your-email&gt;</code><br>比如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl create secret docker-registry mysecret --docker-server=yourRegistry.com --docker-username=sdn --docker-password=sdn123 --docker-email=zhicheng_ren@163.com</span><br></pre></td></tr></table></figure></li><li><p>查看创建的 secret</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># kubectl get secret</span><br><span class="line">NAME        TYPE                      DATA      AGE</span><br><span class="line">sdnsecret   kubernetes.io/dockercfg   1         3m</span><br></pre></td></tr></table></figure></li><li><p>rc 中使用 Secret<br>获取 private registry 中的 docker image 时，需要使用对应的 secret 提供访问权限<br>在 rc 中 spec.template.spec 下添加 imagePullSecrets 指定使用的 secret<br>比如：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">ReplicationController</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"><span class="attr">  name:</span> <span class="string">lab-cloud-controller</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line"><span class="attr">  replicas:</span> <span class="number">1</span></span><br><span class="line"><span class="attr">  selector:</span></span><br><span class="line"><span class="attr">    app:</span> <span class="string">lab-cloud-controller</span></span><br><span class="line"><span class="attr">  template:</span></span><br><span class="line"><span class="attr">    metadata:</span></span><br><span class="line"><span class="attr">      labels:</span></span><br><span class="line"><span class="attr">        app:</span> <span class="string">lab-cloud-controller</span></span><br><span class="line"><span class="attr">    spec:</span></span><br><span class="line"><span class="attr">      containers:</span></span><br><span class="line"><span class="attr">      - name:</span> <span class="string">lab-cloud-controller</span></span><br><span class="line"><span class="attr">        image:</span> <span class="string">lab-cloud/lab-cloud-controller:latest</span></span><br><span class="line"><span class="attr">        ports:</span></span><br><span class="line"><span class="attr">        - containerPort:</span> <span class="number">8080</span></span><br><span class="line"><span class="attr">          hostPort:</span> <span class="number">8082</span></span><br><span class="line"><span class="attr">        - containerPort:</span> <span class="number">5005</span></span><br><span class="line"><span class="attr">          hostPort:</span> <span class="number">5005</span></span><br><span class="line"><span class="attr">        env:</span></span><br><span class="line"><span class="attr">        - name:</span> <span class="string">NSO_SERVICE_HOST</span></span><br><span class="line"><span class="attr">          value:</span> <span class="string">"nso-service"</span></span><br><span class="line"><span class="attr">        - name:</span> <span class="string">NSO_SERVICE_PORT</span></span><br><span class="line"><span class="attr">          value:</span> <span class="string">"8080"</span></span><br><span class="line"><span class="attr">        - name:</span> <span class="string">CASSANDRA_HOST</span></span><br><span class="line"><span class="attr">          value:</span> <span class="string">"cassandra"</span></span><br><span class="line"><span class="attr">        - name:</span> <span class="string">CASSANDRA_PORT</span></span><br><span class="line"><span class="attr">          value:</span> <span class="string">"9042"</span></span><br><span class="line"><span class="attr">      imagePullSecrets:</span></span><br><span class="line"><span class="attr">        - name:</span> <span class="string">sdnsecret</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="外部系统访问Service的问题"><a href="#外部系统访问Service的问题" class="headerlink" title="外部系统访问Service的问题"></a>外部系统访问Service的问题</h2><p>Kubernetes中有三种IP：</p><ul><li>Node IP：Node节点的IP地址</li><li>Pod IP：Pod的IP地址</li><li>Cluster IP：Service的IP地址<br>Service的Cluster IP属于Kubernetes集群内部的地址，无法在集群外部直接使用这个地址。<br>采用<code>NodePort</code>是解决此问题最直接有效的办法，具体做法如下，以部署mongodb service(mongo-svc.yaml)为例：<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Service</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"><span class="attr">  labels:</span></span><br><span class="line"><span class="attr">    name:</span> <span class="string">mongo</span></span><br><span class="line"><span class="attr">  name:</span> <span class="string">mongo</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line"><span class="attr">  type:</span> <span class="string">NodePort</span></span><br><span class="line"><span class="attr">  ports:</span></span><br><span class="line"><span class="attr">    - port:</span> <span class="number">27017</span></span><br><span class="line"><span class="attr">      nodePort:</span> <span class="number">27017</span></span><br><span class="line"><span class="attr">  selector:</span></span><br><span class="line"><span class="attr">    name:</span> <span class="string">mongo</span></span><br><span class="line"><span class="attr">  sessionAffinity:</span> <span class="string">None</span></span><br></pre></td></tr></table></figure></li></ul><p>NodePort的实现方式是在Kubernetes集群里的每个Node上为需要外部访问的Service开启一个对应的TCP监听端口，外部系统只要用任意一个Node的IP地址+具体的NodePort端口号即可访问此服务。下面为在任意节点netstat运行后的结果：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tcp6       0      0 [::]:27017              [::]:*                  LISTEN      4015/kube-proxy</span><br></pre></td></tr></table></figure><p></p><p>注意：请查看docker已正确启动后再启动服务，否则服务将无法访问，可使用如下命令查看：<br><code>kubectl logs &lt;PodName&gt;</code></p><p>若一直卡在“waiting for connection”这个进程，可能是端口冲突导致container无法创建，这样即使服务创建好外部也无法访问。<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">2017-11-01T20:11:38.314+0000 I CONTROL  [initandlisten] MongoDB starting : pid=1 port=27017 dbpath=/data/db 64-bit host=mongo-controller-nbgsr</span><br><span class="line">2017-11-01T20:11:38.314+0000 I CONTROL  [initandlisten] db version v3.4.10</span><br><span class="line">2017-11-01T20:11:38.314+0000 I CONTROL  [initandlisten] git version: 078f28920cb24de0dd479b5ea6c66c644f6326e9</span><br><span class="line">2017-11-01T20:11:38.314+0000 I CONTROL  [initandlisten] OpenSSL version: OpenSSL 1.0.1t  3 May 2016</span><br><span class="line">2017-11-01T20:11:38.314+0000 I CONTROL  [initandlisten] allocator: tcmalloc</span><br><span class="line">2017-11-01T20:11:38.314+0000 I CONTROL  [initandlisten] modules: none</span><br><span class="line">2017-11-01T20:11:38.314+0000 I CONTROL  [initandlisten] build environment:</span><br><span class="line">2017-11-01T20:11:38.314+0000 I CONTROL  [initandlisten]     distmod: debian81</span><br><span class="line">2017-11-01T20:11:38.314+0000 I CONTROL  [initandlisten]     distarch: x86_64</span><br><span class="line">2017-11-01T20:11:38.314+0000 I CONTROL  [initandlisten]     target_arch: x86_64</span><br><span class="line">2017-11-01T20:11:38.314+0000 I CONTROL  [initandlisten] options: &#123;&#125;</span><br><span class="line">2017-11-01T20:11:38.318+0000 I -        [initandlisten] Detected data files <span class="keyword">in</span> /data/db created by the <span class="string">'wiredTiger'</span> storage engine, so setting the active storage engine to <span class="string">'wiredTiger'</span>.</span><br><span class="line">2017-11-01T20:11:38.318+0000 I STORAGE  [initandlisten] wiredtiger_open config: create,cache_size=31621M,session_max=20000,eviction=(threads_min=4,threads_max=4),config_base=<span class="literal">false</span>,statistics=(fast),<span class="built_in">log</span>=(enabled=<span class="literal">true</span>,archive=<span class="literal">true</span>,path=journal,compressor=snappy),file_manager=(close_idle_time=100000),checkpoint=(<span class="built_in">wait</span>=60,log_size=2GB),statistics_log=(<span class="built_in">wait</span>=0),</span><br><span class="line">2017-11-01T20:11:38.935+0000 I CONTROL  [initandlisten] </span><br><span class="line">2017-11-01T20:11:38.936+0000 I CONTROL  [initandlisten] ** WARNING: Access control is not enabled <span class="keyword">for</span> the database.</span><br><span class="line">2017-11-01T20:11:38.936+0000 I CONTROL  [initandlisten] **          Read and write access to data and configuration is unrestricted.</span><br><span class="line">2017-11-01T20:11:38.936+0000 I CONTROL  [initandlisten] </span><br><span class="line">2017-11-01T20:11:38.936+0000 I CONTROL  [initandlisten] </span><br><span class="line">2017-11-01T20:11:38.936+0000 I CONTROL  [initandlisten] ** WARNING: /sys/kernel/mm/transparent_hugepage/enabled is <span class="string">'always'</span>.</span><br><span class="line">2017-11-01T20:11:38.936+0000 I CONTROL  [initandlisten] **        We suggest setting it to <span class="string">'never'</span></span><br><span class="line">2017-11-01T20:11:38.936+0000 I CONTROL  [initandlisten] </span><br><span class="line">2017-11-01T20:11:38.936+0000 I CONTROL  [initandlisten] ** WARNING: /sys/kernel/mm/transparent_hugepage/defrag is <span class="string">'always'</span>.</span><br><span class="line">2017-11-01T20:11:38.936+0000 I CONTROL  [initandlisten] **        We suggest setting it to <span class="string">'never'</span></span><br><span class="line">2017-11-01T20:11:38.936+0000 I CONTROL  [initandlisten] </span><br><span class="line">2017-11-01T20:11:38.938+0000 I FTDC     [initandlisten] Initializing full-time diagnostic data capture with directory <span class="string">'/data/db/diagnostic.data'</span></span><br><span class="line">2017-11-01T20:11:38.938+0000 I NETWORK  [thread1] waiting <span class="keyword">for</span> connections on port 27017</span><br></pre></td></tr></table></figure><p></p><h2 id="存储卷本地挂载实现"><a href="#存储卷本地挂载实现" class="headerlink" title="存储卷本地挂载实现"></a>存储卷本地挂载实现</h2><p>在一般情况下，若不进行存储卷设置，Pod或者rc一旦被删除，之前数据库存储的数据便会丢失。<code>Volume</code>的使用比较简单，在大多数情况下，先在Pod上声明一个Volume，然后在容器内引用该Volume并挂载mount到容器内的某个目录上。例子mongo-rc.yaml如下(注意缩进问题)：<br></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spec:</span></span><br><span class="line"><span class="attr">   containers:</span></span><br><span class="line"><span class="attr">   - image:</span> <span class="string">mongo</span></span><br><span class="line"><span class="attr">     name:</span> <span class="string">mongo</span></span><br><span class="line"><span class="attr">     ports:</span></span><br><span class="line"><span class="attr">     - name:</span> <span class="string">mongo</span></span><br><span class="line"><span class="attr">       containerPort:</span> <span class="number">27017</span></span><br><span class="line"><span class="attr">     volumeMounts:</span></span><br><span class="line"><span class="attr">         - mountPath:</span> <span class="string">/data/db</span></span><br><span class="line"><span class="attr">           name:</span> <span class="string">mongo-persistent-storage</span></span><br><span class="line"><span class="attr">    volumes:</span></span><br><span class="line"><span class="attr">         - name:</span> <span class="string">mongo-persistent-storage</span></span><br><span class="line"><span class="attr">           hostPath:</span></span><br><span class="line"><span class="attr">              path:</span> <span class="string">/data/db/mongo_data</span></span><br></pre></td></tr></table></figure><p></p><p>这样便将宿主机上<code>/data/db/mongo_data</code>的本地存储卷挂载到了容器内的<code>/data/db</code>目录上，这样MongoDB一旦进行写入数据操作，本地即会进行相应的缓存操作。就算rc、pod、service挂了，当服务重启时，它会加载本地缓存数据，及时的恢复数据。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近忙于面试，为了缓解紧张的备战心情，更新一下之前总结的一些关于k8s的部署指南，包括&lt;strong&gt;单机版&lt;/strong&gt;和&lt;strong&gt;集群版&lt;/strong&gt;。&lt;br&gt;&lt;img src=&quot;https://ws1.sinaimg.cn/large/73d640f7gy1ftl9vxtsxvj20wp0fkdmx.jpg&quot; alt=&quot;&quot;&gt;&lt;br&gt;
    
    </summary>
    
      <category term="容器云" scheme="https://jasonren.top/categories/%E5%AE%B9%E5%99%A8%E4%BA%91/"/>
    
    
      <category term="kubernetes" scheme="https://jasonren.top/tags/kubernetes/"/>
    
  </entry>
  
  <entry>
    <title>ConcurrentHashMap总结</title>
    <link href="https://jasonren.top/2018/03/02/ConcurrentHashMap/"/>
    <id>https://jasonren.top/2018/03/02/ConcurrentHashMap/</id>
    <published>2018-03-01T16:00:00.000Z</published>
    <updated>2018-11-22T07:51:49.930Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://ws1.sinaimg.cn/large/73d640f7gy1ftl9urrcioj20d707i74i.jpg" alt="ConcurrentHashMap类图"></p><h3 id="在并发中使用ConcurrentHashMap的原因"><a href="#在并发中使用ConcurrentHashMap的原因" class="headerlink" title="在并发中使用ConcurrentHashMap的原因"></a>在并发中使用ConcurrentHashMap的原因</h3><ol><li>HashMap线程不安全，在并发执行put操作时会引起死循环，因为多线程会导致HashMap的Entry链表形成环形数据结构</li><li>HashTable效率低下，使用synchronized保证线程安全，在线程竞争激烈的情况下效率非常低下</li><li>ConcurrentHashMap的锁分段技术可有效提升并发访问率，将数据分成一段一段地存储，然后给每一段数据一把锁，当一个线程占用锁访问其中一个段数据的时候，其他段的数据也能被其它线程访问<a id="more"></a></li></ol><h3 id="ConcurrentHashMap的结构"><a href="#ConcurrentHashMap的结构" class="headerlink" title="ConcurrentHashMap的结构"></a>ConcurrentHashMap的结构</h3><p><img src="https://res.infoq.com/articles/ConcurrentHashMap/zh/resources/1.jpg" alt="image"><br><img src="https://res.infoq.com/articles/ConcurrentHashMap/zh/resources/2.jpg" alt="image"></p><ol><li>ConcurrentHashMap是由Segment数组结构和HashEntry数组结构组成。</li><li>Segment是一种可重入锁（ReentrantLock），在ConcurrentHashMap里扮演锁的角色；HashEntry则用于存储键值对数据。</li><li>一个ConcurrentHashMap里包含一个Segment数组，Segment的结构和HashMap类似，是一种数组和链表结构。</li><li>一个Segment里包含一个HashEntry数组，每个HashEntry是一个链表结构的元素。</li></ol><h3 id="ConcurrentHashMap的初始化"><a href="#ConcurrentHashMap的初始化" class="headerlink" title="ConcurrentHashMap的初始化"></a>ConcurrentHashMap的初始化</h3><ol><li>初始化segments数组<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (concurrencyLevel &gt; MAX_SEGMENTS)</span><br><span class="line">    concurrencyLevel = MAX_SEGMENTS;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Find power-of-two sizes best matching arguments</span></span><br><span class="line"><span class="keyword">int</span> sshift = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> ssize = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (ssize &lt; concurrencyLevel) &#123;</span><br><span class="line">    ++sshift;</span><br><span class="line">    ssize &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">segmentShift = <span class="number">32</span> - sshift;</span><br><span class="line">segmentMask = ssize - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">this</span>.segments = Segment.newArray(ssize);</span><br></pre></td></tr></table></figure></li></ol><p>segments数组长度ssize是通过concurrencyLevel计算得出，为了能通过按位与的散列算法来定位segments数组的索引，必须保证segments数组的长度是2的N次方。即concurrencyLevel等于14、15或16，ssize都会等于16，即容器里锁的个数也是16。</p><ol start="2"><li>初始化segmentShift和segmentMask</li></ol><p>&emsp;&emsp;这两个全局变量在定位segment时的哈希算法里需要使用，sshift等于ssize从1向左移位的次数，在默认情况下concurrencyLevel等于16，1需要向左移位移动4次，所以sshift等于4。segmentShift用于<strong>定位参与hash运算的位数</strong>，segmentShift等于32减sshift，所以等于28，这里之所以用32是因为ConcurrentHashMap里的hash()方法输出的最大数是32位的，后面的测试中我们可以看到这点。<br><br>&emsp;&emsp;segmentMask是<strong>哈希运算的掩码</strong>，等于ssize减1，即15，掩码的二进制各个位的值都是1。因为ssize的最大长度是65536，所以segmentShift最大值是16，segmentMask最大值是65535，对应的二进制是16位，每个位都是1。</p><ol start="3"><li>初始化每个segment</li></ol><p>输入参数initialCapacity是ConcurrentHashMap的初始化容量，loadfactor是每个segment的负载因子，在构造方法里需要通过这两个参数来初始化数组中的每个segment。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (initialCapacity &gt; MAXIMUM_CAPACITY)</span><br><span class="line">    initialCapacity = MAXIMUM_CAPACITY;</span><br><span class="line"><span class="keyword">int</span> c = initialCapacity / ssize;</span><br><span class="line"><span class="keyword">if</span> (c * ssize &lt; initialCapacity)</span><br><span class="line">    ++c;</span><br><span class="line"><span class="keyword">int</span> cap = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (cap &lt; c)</span><br><span class="line">    cap &lt;&lt;= <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>.segments.length; ++i)</span><br><span class="line">    <span class="keyword">this</span>.segments[i] = <span class="keyword">new</span> Segment&lt;K,V&gt;(cap, loadFactor);</span><br></pre></td></tr></table></figure><p>上面代码中的变量cap就是segment里HashEntry数组的长度，它等于initialCapacity除以ssize的倍数c，如果c大于1，就会取大于等于c的2的N次方值，所以cap不是1，就是2的N次方。segment的容量threshold＝(int)cap*loadFactor，默认情况下initialCapacity等于16，loadfactor等于0.75，通过运算cap等于1，threshold等于零。</p><h3 id="定位Segment"><a href="#定位Segment" class="headerlink" title="定位Segment"></a>定位Segment</h3><p>既然ConcurrentHashMap使用分段锁Segment来保护不同段的数据，那么在插入和获取元素的时候，必须先通过哈希算法定位到Segment。可以看到ConcurrentHashMap会首先使用<strong>Wang/Jenkins hash</strong>的变种算法对元素的hashCode进行一次再哈希。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(<span class="keyword">int</span> h)</span> </span>&#123;</span><br><span class="line">        h += (h &lt;&lt; <span class="number">15</span>) ^ <span class="number">0xffffcd7d</span>;</span><br><span class="line">        h ^= (h &gt;&gt;&gt; <span class="number">10</span>);</span><br><span class="line">        h += (h &lt;&lt; <span class="number">3</span>);</span><br><span class="line">        h ^= (h &gt;&gt;&gt; <span class="number">6</span>);</span><br><span class="line">        h += (h &lt;&lt; <span class="number">2</span>) + (h &lt;&lt; <span class="number">14</span>);</span><br><span class="line">        <span class="keyword">return</span> h ^ (h &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>之所以进行再哈希，其目的是为了减少哈希冲突，使元素能够均匀的分布在不同的Segment上，从而提高容器的存取效率。假如哈希的质量差到极点，那么所有的元素都在一个Segment中，不仅存取元素缓慢，分段锁也会失去意义。我做了一个测试，不通过再哈希而直接执行哈希计算。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(Integer.parseInt(<span class="string">"0001111"</span>, <span class="number">2</span>) &amp; <span class="number">15</span>);</span><br><span class="line">System.out.println(Integer.parseInt(<span class="string">"0011111"</span>, <span class="number">2</span>) &amp; <span class="number">15</span>);</span><br><span class="line">System.out.println(Integer.parseInt(<span class="string">"0111111"</span>, <span class="number">2</span>) &amp; <span class="number">15</span>);</span><br><span class="line">System.out.println(Integer.parseInt(<span class="string">"1111111"</span>, <span class="number">2</span>) &amp; <span class="number">15</span>);</span><br></pre></td></tr></table></figure><p>计算后输出的哈希值全是15，通过这个例子可以发现如果不进行再哈希，哈希冲突会非常严重，因为只要低位一样，无论高位是什么数，其哈希值总是一样。我们再把上面的二进制数据进行再哈希后结果如下，为了方便阅读，不足32位的高位补了0，每隔四位用竖线分割下。<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">0100｜0111｜0110｜0111｜1101｜1010｜0100｜1110</span><br><span class="line">1111｜0111｜0100｜0011｜0000｜0001｜1011｜1000</span><br><span class="line">0111｜0111｜0110｜1001｜0100｜0110｜0011｜1110</span><br><span class="line">1000｜0011｜0000｜0000｜1100｜1000｜0001｜1010</span><br></pre></td></tr></table></figure><p></p><p>可以发现每一位的数据都散列开了，通过这种再哈希能让数字的每一位都能参加到哈希运算当中，从而减少哈希冲突。ConcurrentHashMap通过以下哈希算法定位segment。<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> Segment&lt;K,V&gt; <span class="title">segmentFor</span><span class="params">(<span class="keyword">int</span> hash)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> segments[(hash &gt;&gt;&gt; segmentShift) &amp; segmentMask];</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p></p><p>默认情况下segmentShift为28，segmentMask为15，再哈希后的数最大是32位二进制数据，向右无符号移动28位，意思是让高4位参与到hash运算中， (hash &gt;&gt;&gt; segmentShift) &amp; segmentMask的运算结果分别是4，15，7和8，可以看到hash值没有发生冲突。</p><h3 id="ConcurrentHashMap操作"><a href="#ConcurrentHashMap操作" class="headerlink" title="ConcurrentHashMap操作"></a>ConcurrentHashMap操作</h3><h4 id="get操作"><a href="#get操作" class="headerlink" title="get操作"></a>get操作</h4><p>Segment的get操作实现非常简单和高效。先经过一次再哈希，然后使用这个哈希值通过哈希运算定位到segment，再通过哈希算法定位到元素，代码如下：<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> hash = hash(key.hashCode());</span><br><span class="line">    <span class="keyword">return</span> segmentFor(hash).get(key, hash);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>get操作的高效之处在于整个get过程不需要加锁，除非读到的值是空的才会加锁重读，我们知道HashTable容器的get方法是需要加锁的，那么ConcurrentHashMap的get操作是如何做到不加锁的呢？原因是它的get方法里将要使用的共享变量都定义成volatile，如用于统计当前Segement大小的count字段和用于存储值的HashEntry的value。定义成volatile的变量，能够在线程之间保持可见性，能够被多线程同时读，并且保证不会读到过期的值，但是只能被单线程写（有一种情况可以被多线程写，就是写入的值不依赖于原值），在get操作里只需要读不需要写共享变量count和value，所以可以不用加锁。之所以不会读到过期的值，是根据java内存模型的happen before原则，对volatile字段的写入操作先于读操作，即使两个线程同时修改和获取volatile变量，get操作也能拿到最新的值，这是用volatile替换锁的经典应用场景。<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">transient</span> <span class="keyword">volatile</span> <span class="keyword">int</span> count;</span><br><span class="line"><span class="keyword">volatile</span> V value;</span><br></pre></td></tr></table></figure><p></p><p>在定位元素的代码里我们可以发现定位HashEntry和定位Segment的哈希算法虽然一样，都与数组的长度减去一相与，但是相与的值不一样，<strong>定位Segment使用的是元素的hashcode通过再哈希后得到的值的高位</strong>，而<strong>定位HashEntry直接使用的是再哈希后的值</strong>。其目的是避免两次哈希后的值一样，<strong>导致元素虽然在Segment里散列开了，但是却没有在HashEntry里散列开</strong>。<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hash &gt;&gt;&gt; segmentShift) &amp; segmentMask<span class="comment">//定位Segment所使用的hash算法</span></span><br><span class="line"><span class="keyword">int</span> index = hash &amp; (tab.length - <span class="number">1</span>);<span class="comment">// 定位HashEntry所使用的hash算法</span></span><br></pre></td></tr></table></figure><p></p><h4 id="put操作"><a href="#put操作" class="headerlink" title="put操作"></a>put操作</h4><p>由于put方法里需要对共享变量进行写入操作，所以为了线程安全，在操作共享变量时必须得加锁。Put方法首先定位到Segment，然后在Segment里进行插入操作。插入操作需要经历两个步骤，第一步判断是否需要对Segment里的HashEntry数组进行扩容，第二步定位添加元素的位置然后放在HashEntry数组里。</p><p><strong>是否需要扩容</strong>。在插入元素前会先判断Segment里的HashEntry数组是否超过容量（threshold），如果超过阀值，数组进行扩容。值得一提的是，Segment的扩容判断比HashMap更恰当，因为HashMap是在插入元素后判断元素是否已经到达容量的，如果到达了就进行扩容，但是很有可能扩容之后没有新元素插入，这时HashMap就进行了一次无效的扩容。</p><p><strong>如何扩容</strong>。扩容的时候首先会创建一个两倍于原容量的数组，然后将原数组里的元素进行再hash后插入到新的数组里。为了高效ConcurrentHashMap不会对整个容器进行扩容，而只对某个segment进行扩容。</p><h4 id="size操作"><a href="#size操作" class="headerlink" title="size操作"></a>size操作</h4><p>如果我们要统计整个ConcurrentHashMap里元素的大小，就必须统计所有Segment里元素的大小后求和。Segment里的全局变量count是一个volatile变量，那么在多线程场景下，我们是不是直接把所有Segment的count相加就可以得到整个ConcurrentHashMap大小了呢？不是的，虽然相加时可以获取每个Segment的count的最新值，但是拿到之后可能累加前使用的count发生了变化，那么统计结果就不准了。所以最安全的做法，是在统计size的时候把所有Segment的put，remove和clean方法全部锁住，但是这种做法显然非常低效。<br>因为在累加count操作过程中，之前累加过的count发生变化的几率非常小，所以ConcurrentHashMap的做法是先尝试2次通过不锁住Segment的方式来统计各个Segment大小，如果统计的过程中，容器的count发生了变化，则再采用加锁的方式来统计所有Segment的大小。</p><p>那么ConcurrentHashMap是如何判断在统计的时候容器是否发生了变化呢？使用modCount变量，在put , remove和clean方法里操作元素前都会将变量modCount进行加1，那么在统计size前后比较modCount是否发生变化，从而得知容器的大小是否发生变化。<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns the number of key-value mappings in this map.  If the</span></span><br><span class="line"><span class="comment">     * map contains more than &lt;tt&gt;Integer.MAX_VALUE&lt;/tt&gt; elements, returns</span></span><br><span class="line"><span class="comment">     * &lt;tt&gt;Integer.MAX_VALUE&lt;/tt&gt;.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> the number of key-value mappings in this map</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> Segment&lt;K,V&gt;[] segments = <span class="keyword">this</span>.segments;</span><br><span class="line">        <span class="keyword">long</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">long</span> check = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span>[] mc = <span class="keyword">new</span> <span class="keyword">int</span>[segments.length];</span><br><span class="line">        <span class="comment">// Try a few times to get accurate count. On failure due to</span></span><br><span class="line">        <span class="comment">// continuous async changes in table, resort to locking.</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; RETRIES_BEFORE_LOCK; ++k) &#123;</span><br><span class="line">            check = <span class="number">0</span>;</span><br><span class="line">            sum = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">int</span> mcsum = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; segments.length; ++i) &#123;</span><br><span class="line">                sum += segments[i].count;</span><br><span class="line">                mcsum += mc[i] = segments[i].modCount;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (mcsum != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; segments.length; ++i) &#123;</span><br><span class="line">                    check += segments[i].count;</span><br><span class="line">                    <span class="keyword">if</span> (mc[i] != segments[i].modCount) &#123;</span><br><span class="line">                        check = -<span class="number">1</span>; <span class="comment">// force retry</span></span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (check == sum)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (check != sum) &#123; <span class="comment">// Resort to locking all segments</span></span><br><span class="line">            sum = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; segments.length; ++i)</span><br><span class="line">                segments[i].lock();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; segments.length; ++i)</span><br><span class="line">                sum += segments[i].count;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; segments.length; ++i)</span><br><span class="line">                segments[i].unlock();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (sum &gt; Integer.MAX_VALUE)</span><br><span class="line">            <span class="keyword">return</span> Integer.MAX_VALUE;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> (<span class="keyword">int</span>)sum;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://ws1.sinaimg.cn/large/73d640f7gy1ftl9urrcioj20d707i74i.jpg&quot; alt=&quot;ConcurrentHashMap类图&quot;&gt;&lt;/p&gt;&lt;h3 id=&quot;在并发中使用ConcurrentHashMap的原因&quot;&gt;&lt;a href=&quot;#在并发中使用ConcurrentHashMap的原因&quot; class=&quot;headerlink&quot; title=&quot;在并发中使用ConcurrentHashMap的原因&quot;&gt;&lt;/a&gt;在并发中使用ConcurrentHashMap的原因&lt;/h3&gt;&lt;ol&gt;&lt;li&gt;HashMap线程不安全，在并发执行put操作时会引起死循环，因为多线程会导致HashMap的Entry链表形成环形数据结构&lt;/li&gt;&lt;li&gt;HashTable效率低下，使用synchronized保证线程安全，在线程竞争激烈的情况下效率非常低下&lt;/li&gt;&lt;li&gt;ConcurrentHashMap的锁分段技术可有效提升并发访问率，将数据分成一段一段地存储，然后给每一段数据一把锁，当一个线程占用锁访问其中一个段数据的时候，其他段的数据也能被其它线程访问
    
    </summary>
    
      <category term="Java" scheme="https://jasonren.top/categories/Java/"/>
    
    
      <category term="并发" scheme="https://jasonren.top/tags/%E5%B9%B6%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>快速排序的实现及优化方法</title>
    <link href="https://jasonren.top/2018/02/01/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F%E4%BC%98%E5%8C%96/"/>
    <id>https://jasonren.top/2018/02/01/快速排序优化/</id>
    <published>2018-01-31T16:00:00.000Z</published>
    <updated>2018-11-22T07:51:49.933Z</updated>
    
    <content type="html"><![CDATA[<h2 id="快速排序的基本实现"><a href="#快速排序的基本实现" class="headerlink" title="快速排序的基本实现"></a>快速排序的基本实现</h2><p>快速排序算法是一种基于交换的高效的排序算法，它采用了分治法的思想：</p><ol><li>从数列中取出一个数作为基准数（枢轴，pivot）。</li><li>将数组进行划分(partition)，将比基准数大的元素都移至枢轴右边，将小于等于基准数的元素都移至枢轴左边。</li><li>再对左右的子区间重复第二步的划分操作，直至每个子区间只有一个元素。</li></ol><a id="more"></a><p>具体实现如下：<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">QuickSort</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">partition</span><span class="params">(Comparable[] a, <span class="keyword">int</span> lo, <span class="keyword">int</span> hi)</span></span>&#123;</span><br><span class="line">        <span class="comment">//partition array into a[lo..i - 1], a[i], a[i + 1..hi]</span></span><br><span class="line">        <span class="keyword">int</span> i = lo, j = hi + <span class="number">1</span>;</span><br><span class="line">        Comparable v = a[lo];</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line">            <span class="keyword">while</span>(Example.less(a[++i], v)) &#123;&#125;</span><br><span class="line">            <span class="keyword">while</span>(Example.less(v, a[--j])) &#123;&#125;</span><br><span class="line">            <span class="keyword">if</span>(i &gt;= j) <span class="keyword">break</span>;</span><br><span class="line">            Example.exch(a, i, j);</span><br><span class="line">        &#125;</span><br><span class="line">        Example.exch(a, lo, j); <span class="comment">//place v = a[j] in the right location</span></span><br><span class="line">        <span class="keyword">return</span> j; <span class="comment">//a[lo..j-1] &lt;= a[j] &lt;= a[j+1..hi]</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(Comparable[] a)</span></span>&#123;</span><br><span class="line">        Collections.shuffle(Arrays.asList(a));</span><br><span class="line">        sort(a, <span class="number">0</span>, a.length - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(Comparable[] a, <span class="keyword">int</span> lo, <span class="keyword">int</span> hi)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(hi &lt;= lo) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">int</span> j = partition(a, lo, hi);</span><br><span class="line">        sort(a, lo, j - <span class="number">1</span>);</span><br><span class="line">        sort(a, j + <span class="number">1</span>, hi);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Integer[] a = &#123;<span class="number">2</span>,<span class="number">6</span>,<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">4</span>&#125;;</span><br><span class="line">        System.out.print(<span class="string">"The array befor sort is "</span>);</span><br><span class="line">        Example.show(a);</span><br><span class="line">        sort(a);</span><br><span class="line">        System.out.print(<span class="string">"The array after sort is "</span>);</span><br><span class="line">        Example.show(a);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><h2 id="快速排序的优化及改进方法"><a href="#快速排序的优化及改进方法" class="headerlink" title="快速排序的优化及改进方法"></a>快速排序的优化及改进方法</h2><h3 id="切换到插入排序"><a href="#切换到插入排序" class="headerlink" title="切换到插入排序"></a>切换到插入排序</h3><ul><li>对于小数组，快速排序比插入排序慢</li><li>因为递归，快速排序的sort()方法在小数组中也会调用自己</li></ul><p>只需将递归的的函数出口，即<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(hi &lt;= lo) <span class="keyword">return</span>;</span><br></pre></td></tr></table></figure><p></p><p>替换为<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(hi &lt;= lo + M)&#123;Insertion.sort(a, lo, hi); <span class="keyword">return</span>;&#125;</span><br></pre></td></tr></table></figure><p></p><p>其中<strong>转换参数M</strong>在5~15之间取值在大多数情况下都能令人满意</p><h3 id="三取样切分"><a href="#三取样切分" class="headerlink" title="三取样切分"></a>三取样切分</h3><p>使用子数组的一小部分元素的中位数来切分数组，这样做得到的切分更好，但代价是需要计算中位数，人们发现将取样大小设为3并用大小居中的元素切分的效果最好。</p><h3 id="快速三向切分法"><a href="#快速三向切分法" class="headerlink" title="快速三向切分法"></a>快速三向切分法</h3><p>在有大量重复元素的情况下，快速排序的递归性会使元素全部重复的子数组经常出现，这就有很大的改进潜力，将当前实现的线性对数级的性能提高到线性级别。<br><br>最短路径算法的发明者<strong>Dijkstra</strong>发布了一种最经典的三向切分快速排序算法，维护lt和gt两个指针，仍旧取中枢轴为v=a[lo]，分以下三种情况进行讨论：</p><ul><li>a[i]小于v，将a[lt]和a[i]交换，将lt和i加1</li><li>a[i]大于v，将a[gt]和a[i]交换，将gt减1</li><li>a[i]等于v，将i加1</li></ul><p><img src="https://ws1.sinaimg.cn/large/73d640f7ly1fuyqk4hblcj20dm09jt8v.jpg" alt="快速三向切分"></p><p>下面是实现：<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(Comparable[] a, <span class="keyword">int</span> lo, <span class="keyword">int</span> hi)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(hi &lt;= lo) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">int</span> lt = lo, i = lo + <span class="number">1</span>, gt = hi;</span><br><span class="line">        Comparable v = a[lo];</span><br><span class="line">        <span class="keyword">while</span>(i &lt;= gt)&#123;</span><br><span class="line">            <span class="keyword">int</span> cmp = a[i].compareTo(v);</span><br><span class="line">            <span class="keyword">if</span>(cmp &lt; <span class="number">0</span>) Example.exch(a, lt++, i++);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(cmp &gt; <span class="number">0</span>) Example.exch(a, i, gt--);</span><br><span class="line">            <span class="keyword">else</span> ++i;</span><br><span class="line">        &#125;<span class="comment">// now a[lo..lt-1] &lt; v = a[lt..gt] &lt; a[gt+1..hi]</span></span><br><span class="line">        sort(a, lo, lt - <span class="number">1</span>);</span><br><span class="line">        sort(a, gt + <span class="number">1</span>, hi);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p></p><p><strong>J.Bentley</strong>和<strong>D.McIlroy</strong>找到了一种新的快速三向切分的方法（<strong>Bentley-McIlroy 3-way partitioning</strong>），解决了重复元素不多的情况下交换次数过多的问题<br></p><p>第一阶段（重复循环直到i和j指针相遇）：</p><ul><li>Scan i from left to right so long as (a[i] &lt; a[lo]).</li><li>Scan j from right to left so long as (a[j] &gt; a[lo]).</li><li>Exchange a[i] with a[j]</li><li>If (a[i] == a[lo])，exchange a[i] with a[p] and increment p.</li><li>If (a[j] == a[lo])，exchange a[j] with a[q] and decrement q.</li></ul><p>整个过程如下图所示：</p><p><img src="https://ws1.sinaimg.cn/large/73d640f7gy1ftl9vvopzpg20o109mdh6.gif" alt="Phase 1"></p><p>具体实现如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Bentley-McIlroy 3-way partitioning</span></span><br><span class="line">       <span class="keyword">int</span> i = lo, j = hi + <span class="number">1</span>;</span><br><span class="line">       <span class="keyword">int</span> p = lo, q = hi + <span class="number">1</span>;</span><br><span class="line">       <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">           Comparable v = a[lo];</span><br><span class="line">           <span class="keyword">while</span> (less(a[++i], v))</span><br><span class="line">               <span class="keyword">if</span> (i == hi) <span class="keyword">break</span>;</span><br><span class="line">           <span class="keyword">while</span> (less(v, a[--j]))</span><br><span class="line">               <span class="keyword">if</span> (j == lo) <span class="keyword">break</span>;</span><br><span class="line">           <span class="keyword">if</span> (i &gt;= j) <span class="keyword">break</span>;</span><br><span class="line">           exch(a, i, j);</span><br><span class="line">           <span class="keyword">if</span> (eq(a[i], v)) exch(a, ++p, i);</span><br><span class="line">           <span class="keyword">if</span> (eq(a[j], v)) exch(a, --q, j);</span><br><span class="line">       &#125;</span><br><span class="line">       exch(a, lo, j);</span><br></pre></td></tr></table></figure><p>第二阶段（<strong>将键值相等的键移到数组中间</strong>）：</p><ul><li>Scan j and p from right to left and exchange a[j] with a[p].</li><li>Scan i and q from left to right and exchange a[i] with a[q].</li></ul><p>整个过程如下图所示：</p><p><img src="https://ws1.sinaimg.cn/large/73d640f7gy1ftl9vvmsatg20o109maac.gif" alt="Phase2"></p><p>具体实现如下图所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">i = j + <span class="number">1</span>;</span><br><span class="line">j = j - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> k = lo + <span class="number">1</span>; k &lt;= p; k++) exch(a, k, j--);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> k = hi; k &gt;= q; k--) exch(a, k, i++);</span><br></pre></td></tr></table></figure><p>类似的快排优化在JDK1.8的<strong>DualPivotQuicksort</strong>也实现过，具体可看其<a href="http://hg.openjdk.java.net/jdk8u/jdk8u/jdk/file/e2117e30fb39/src/share/classes/java/util/DualPivotQuicksort.java" target="_blank" rel="noopener">源码</a>，很奇妙。</p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ol><li><a href="http://www.sczyh30.com/posts/Algorithm/algorithm-quicksort/" target="_blank" rel="noopener">http://www.sczyh30.com/posts/Algorithm/algorithm-quicksort/</a></li><li><a href="https://algs4.cs.princeton.edu/lectures/23DemoPartitioning.pdf" target="_blank" rel="noopener">https://algs4.cs.princeton.edu/lectures/23DemoPartitioning.pdf</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;快速排序的基本实现&quot;&gt;&lt;a href=&quot;#快速排序的基本实现&quot; class=&quot;headerlink&quot; title=&quot;快速排序的基本实现&quot;&gt;&lt;/a&gt;快速排序的基本实现&lt;/h2&gt;&lt;p&gt;快速排序算法是一种基于交换的高效的排序算法，它采用了分治法的思想：&lt;/p&gt;&lt;ol&gt;&lt;li&gt;从数列中取出一个数作为基准数（枢轴，pivot）。&lt;/li&gt;&lt;li&gt;将数组进行划分(partition)，将比基准数大的元素都移至枢轴右边，将小于等于基准数的元素都移至枢轴左边。&lt;/li&gt;&lt;li&gt;再对左右的子区间重复第二步的划分操作，直至每个子区间只有一个元素。&lt;/li&gt;&lt;/ol&gt;
    
    </summary>
    
      <category term="算法" scheme="https://jasonren.top/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="快速排序" scheme="https://jasonren.top/tags/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>数据库锁机制[转]</title>
    <link href="https://jasonren.top/2018/01/31/%E6%95%B0%E6%8D%AE%E5%BA%93%E9%94%81%E6%9C%BA%E5%88%B6/"/>
    <id>https://jasonren.top/2018/01/31/数据库锁机制/</id>
    <published>2018-01-30T16:00:00.000Z</published>
    <updated>2018-11-22T07:51:49.933Z</updated>
    
    <content type="html"><![CDATA[<p><strong><em>本文转自<a href="http://www.hollischuang.com" target="_blank" rel="noopener">blog</a></em></strong></p><blockquote><p>在并发访问下，数据库可能会出现脏读、不可重复读和幻读等读现象，主流数据库为了应对这些问题，引入了事务隔离级别的概念。</p></blockquote><h2 id="并发控制"><a href="#并发控制" class="headerlink" title="并发控制"></a>并发控制</h2><blockquote><p>在计算科学，特别是程序设计、操作系统、多处理机和数据库等领域，并发控制（Concurrency control）是确保及时纠正并由并发操作导致的错误的一种机制。</p></blockquote><p>数据库管理系统（DBMS）中的并发控制的任务是确保在多个事务同时存取数据库中同一数据时，不破坏事务的隔离性、统一性以及数据库的统一性。</p><p>封锁、时间戳、乐观并发控制（乐观锁）和悲观并发控制（悲观锁）是并发控制主要采用的技术手段。</p><a id="more"></a><h2 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h2><p>当并发事务同时访问一个资源时，有可能导致数据不一致，因此需要一种机制来将数据访问顺序化，以保证数据库数据的一致性，锁就是其中的一种机制。</p><blockquote><p>在计算机科学中，锁是在执行多线程时用于强行限制资源访问的同步机制，即用于在并发控制中保证对互斥要求的满足。</p></blockquote><h2 id="锁的分类（oracle）"><a href="#锁的分类（oracle）" class="headerlink" title="锁的分类（oracle）"></a>锁的分类（oracle）</h2><ol><li>按<strong>操作</strong>划分为<strong>DML锁</strong>、<strong>DDL锁</strong></li><li>按<strong>锁的粒度</strong>分为<strong>表级锁</strong>、<strong>行级锁</strong>、<strong>页级锁</strong>（MySQL）</li><li>按<strong>锁的级别</strong>分为<strong>共享锁</strong>、<strong>排他锁</strong></li><li>按<strong>加锁方式</strong>分为<strong>自动锁</strong>、<strong>显示锁</strong></li><li>按<strong>使用方式</strong>分为<strong>乐观锁</strong>、<strong>悲观锁</strong></li></ol><h2 id="乐观锁和悲观锁"><a href="#乐观锁和悲观锁" class="headerlink" title="乐观锁和悲观锁"></a>乐观锁和悲观锁</h2><h3 id="悲观锁"><a href="#悲观锁" class="headerlink" title="悲观锁"></a>悲观锁</h3><blockquote><p>在关系型数据库管理系统里，悲观并发控制（又名“悲观锁”，Pessimistic Concurrency Control，PCC）是一种并发控制的方法。它可以阻止一个事务以影响其他用户的方式来修改数据，如果一个事务执行的操作都对某行数据应用了锁，那只有当这个事务把锁释放，其他事务才能够执行与该锁冲突的操作。其主要应用场景是数据争用激烈的环境，以及发生并发冲突时使用锁保护数据的成本要低于回滚事务的成本的环境中。</p></blockquote><p>悲观锁（Pessimistic Lock），就是对数据被外界（包括本系统当前的其他事务，以及来自外部系统的事务处理）修改总是保持悲观态度，每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，这样别人想拿这个数据就会block直到它拿到锁。<br>悲观锁的实现，往往依赖数据库提供的锁机制（也只有数据库层提供的锁机制才能保证数据访问的排他性，否则，即使在本系统中实现了加锁机制，也无法保证外部系统不会修改数据）</p><h3 id="悲观锁的实现流程"><a href="#悲观锁的实现流程" class="headerlink" title="悲观锁的实现流程"></a>悲观锁的实现流程</h3><ol><li><p>在对任意记录进行修改前，先尝试为该记录加上排它锁（exclusive locking）</p></li><li><p>如果加锁失败，说明该记录正在被修改，那么当前查询可能要等待或者抛出异常。具体响应方式由开发者根据实际需要决定。</p></li><li><p>如果成功加锁，那么就需要对记录做修改，事务完成后就会解锁了</p></li><li><p>期间如果有其他对该记录做修改或者加排它锁的操作，都会等待我们解锁或直接抛出异常</p></li></ol><p><strong><em>Java synchronized 就属于悲观锁的一种实现，每次线程要修改数据时都先获得锁，保证同一时刻只有一个线程能操作数据，其他线程则会被block</em>。</strong></p><h3 id="乐观锁"><a href="#乐观锁" class="headerlink" title="乐观锁"></a>乐观锁</h3><blockquote><p>在关系型数据库管理系统里，乐观并发控制（又名“乐观锁”，Optimistic Concurrency Control，OCC）是一种并发控制的方法。它假设多用户并发的事务在处理时不会彼此相互影响，各事务能够在不产生锁的情况下处理各自影响的那部分数据。在提交数据更新之前，每个事务会会检查在该事务读取数据后，有没有其他事务又修改了该数据。如果存在，正在提交的事务会进行回滚操作（Roll Back）。其应用场景是读多写少的应用场景，这样可以提高吞吐量。</p></blockquote><p>乐观锁（Optimistic Lock），就是对数据被外界（包括本系统当前的其他事务，以及来自外部系统的事务处理）修改总是保持乐观态度，每次去拿数据的时候都认为别人不会修改，所以每次在拿数据的时候都不会上锁，但是在提交更新的时候会判断一下在此期间别人有没有去更新这个数据，如果发现冲突了，则返回用户错误的信息，让用户决定如何处理。<br>相对于悲观锁，在对数据库进行处理的时候，乐观锁并不会使用数据库提供的锁机制。一般的实现乐观锁的方式就是记录数据版本。</p><blockquote><p>“数据版本，为数据增加一个版本标识，当读取数据时，将版本标识的值一同读出，数据每更新一次，同时对版本标识进行更新。当我们提交更新的时候，判断数据库表对应记录的当前版本信息与第一次取出数据时的版本标识进行比对，如果数据库表当前版本号与第一次取出来的版本标识值相等，则予以更新，否则认为是过期数据。”</p></blockquote><p>实现数据版本的方式：</p><ol><li>使用版本号（Version）：即为数据增加一个版本标识，一般是通过为数据库表增加一个数字类型的 “version” 字段来实现。当读取数据时，将version字段的值一同读出，数据每更新一次，对此version值加一。当我们提交更新的时候，判断数据库表对应记录的当前版本信息与第一次取出来的version值进行比对，如果数据库表当前版本号与第一次取出来的version值相等，则予以更新，否则认为是过期数据。</li><li>使用时间戳：乐观锁定的第二种实现方式和第一种差不多，同样是在需要乐观锁控制的table中增加一个字段，名称无所谓，字段类型使用时间戳（timestamp）, 和上面的version类似，也是在更新提交的时候检查当前数据库中数据的时间戳和自己更新前取到的时间戳进行对比，如果一致则OK，否则就是版本冲突。</li></ol><p><strong><em>Java JUC（java.util.concurrent）中atomic包就是乐观锁的一种实现，AtomicInteger通过CAS（Compare And Set）操作实现线程安全的自增</em></strong>。</p><h2 id="共享锁、排它锁和更新锁"><a href="#共享锁、排它锁和更新锁" class="headerlink" title="共享锁、排它锁和更新锁"></a>共享锁、排它锁和更新锁</h2><ul><li>共享锁（S）：又称为读锁，若事务T对数据对象A加上S锁，则事务T可以读A但不能修改A，其他事务只能再对A加S锁，而不能加X锁，直到T释放A上的S锁。（因此，共享锁与共享锁相容）。</li><li>排他锁（X）:又称为写锁。若事务T对数据对象A加上X锁，则只允许T读取和修改A，其他任何事务都不能再对A加任何类型的锁，直到T释放A上的锁。这就保证了其他事务在T释放A上的锁之前不能再读取和修改A。</li><li>更新锁（U）:用来预定要对此页施加X锁，它允许其他事务读，但不允许再施加U锁或X锁；当被读取的页将要被更新时，则升级为X锁；U锁一直到事务结束时才能被释放。</li></ul><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ol><li><a href="http://www.hollischuang.com/archives/909" target="_blank" rel="noopener">http://www.hollischuang.com/archives/909</a></li><li><a href="https://www.jianshu.com/p/f5ff017db62a" target="_blank" rel="noopener">https://www.jianshu.com/p/f5ff017db62a</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;&lt;em&gt;本文转自&lt;a href=&quot;http://www.hollischuang.com&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;blog&lt;/a&gt;&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;在并发访问下，数据库可能会出现脏读、不可重复读和幻读等读现象，主流数据库为了应对这些问题，引入了事务隔离级别的概念。&lt;/p&gt;&lt;/blockquote&gt;&lt;h2 id=&quot;并发控制&quot;&gt;&lt;a href=&quot;#并发控制&quot; class=&quot;headerlink&quot; title=&quot;并发控制&quot;&gt;&lt;/a&gt;并发控制&lt;/h2&gt;&lt;blockquote&gt;&lt;p&gt;在计算科学，特别是程序设计、操作系统、多处理机和数据库等领域，并发控制（Concurrency control）是确保及时纠正并由并发操作导致的错误的一种机制。&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;数据库管理系统（DBMS）中的并发控制的任务是确保在多个事务同时存取数据库中同一数据时，不破坏事务的隔离性、统一性以及数据库的统一性。&lt;/p&gt;&lt;p&gt;封锁、时间戳、乐观并发控制（乐观锁）和悲观并发控制（悲观锁）是并发控制主要采用的技术手段。&lt;/p&gt;
    
    </summary>
    
      <category term="数据库" scheme="https://jasonren.top/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
      <category term="SQL" scheme="https://jasonren.top/tags/SQL/"/>
    
  </entry>
  
  <entry>
    <title>线程不安全的数据结构</title>
    <link href="https://jasonren.top/2017/12/30/%E7%BA%BF%E7%A8%8B%E4%B8%8D%E5%AE%89%E5%85%A8%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BB%93/"/>
    <id>https://jasonren.top/2017/12/30/线程不安全的数据结构总结/</id>
    <published>2017-12-29T16:00:00.000Z</published>
    <updated>2018-11-22T07:51:49.934Z</updated>
    
    <content type="html"><![CDATA[<h2 id="什么是线程安全"><a href="#什么是线程安全" class="headerlink" title="什么是线程安全"></a>什么是线程安全</h2><h3 id="正确性"><a href="#正确性" class="headerlink" title="正确性"></a>正确性</h3><blockquote><p>当多个线程访问某个类时，不管运行时环境采用何种调度方式或者这些线程将如何交替执行，并且在主调代码中不需要任何额外的同步或协同，这个类都能表现出正确的行为，那么就称这个类是线程安全的。</p></blockquote><h3 id="同步"><a href="#同步" class="headerlink" title="同步"></a>同步</h3><blockquote><p>在线程安全类中封装了必要的同步机制，因此客户端无须进一步采用同步措施。</p></blockquote><a id="more"></a><h2 id="常用的线程安全场景"><a href="#常用的线程安全场景" class="headerlink" title="常用的线程安全场景"></a>常用的线程安全场景</h2><ol><li><strong>无状态的一定是线程安全的</strong>。这个很好理解，因为所谓线程不安全也就是一个线程修改了状态，而另一个线程的操作依赖于这个被修改的状态。</li><li><strong>只有一个状态，而且这个状态是由一个线程安全的对象维护的，那这个类也是线程安全的</strong>。比如你在数据结构里只用一个AtomicLong来作为计数器，那递增计数的操作都是线程安全的，不会漏掉任何一次计数，而如果你用普通的long做++操作则不一样，因为++操作本身涉及到取数、递增、赋值 三个操作，某个线程可能取到了另外一个线程还没来得及写回的数就会导致上一次写入丢失。</li><li><strong>有多个状态的情况下，维持不变性（invariant）的所有可变（mutable）状态都用同一个锁来守护的类是线程安全的</strong>。这一段有些拗口，首先类不变性的意思是指这个类在多线程状态下能正确运行的状态，其次用锁守护的意思是所有对该状态的操作都需要获取这个锁，而用同一个锁守护的作用就是所有对这些状态的修改实际最后都是串行的，不会存在某个操作中间状态被其他操作可见，继而导致线程不安全。所以这里的关键在于如何确定不变性，可能你的类的某些状态对于类的正确运行是无关紧要的，那就不需要用和其他状态一样的锁来守护。因此我们常可以看到有的类里面会创建一个新的对象作为锁来守护某些和原类本身不变性无关的状态。</li></ol><p>上面这三种只是一种归纳，具体到实际应用时，要看你的类哪些状态是必须用锁来守护的，灵活变通。</p><h2 id="并发下的ArrayList"><a href="#并发下的ArrayList" class="headerlink" title="并发下的ArrayList"></a>并发下的ArrayList</h2><p>ArrayList是一个线程不安全的容器，具体表现请看下面这段代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayListMultiThread</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> ArrayList&lt;Integer&gt; al = <span class="keyword">new</span> ArrayList&lt;Integer&gt;(<span class="number">10</span>);</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">AddThread</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000000</span>; i++)&#123;</span><br><span class="line">                al.add(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException</span>&#123;</span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> AddThread());</span><br><span class="line">        Thread t2 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> AddThread());</span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">        t1.join();t2.join();</span><br><span class="line">        System.out.println(al.size());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码实现的是采用t1和t2两个线程向一个ArrayList容器中添加元素，最后我们期望可以有2000000个元素在ArrayList中，但事与愿违，你将得到以下三种结果：</p><ol><li><p>跟你期待的一样，最后打印结果为2000000。</p></li><li><p>抛数组越界异常：<br><img src="https://ws1.sinaimg.cn/large/73d640f7gy1ftl9uridvrj20oc030dfu.jpg" alt=""></p><p>这是由于ArrayList扩容过程中，内部一致性遭到破坏，但由于没有锁的保护，当另一个线程访问到了不一致的内部状态，导致出现越界问题。</p></li><li><p>第三种情况是最为头疼的情况，因为它并没有报错：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1321889</span></span><br></pre></td></tr></table></figure></li></ol><p>显然这是由于多线程之间的访问冲突，使得保存容器大小的变量被多线程不正常的访问，同时两个线程也同时对ArrayList中的同一个位置进行赋值导致的。<br><br>解决方法很简单，只需要将ArrayList换成线程安全的容器vector即可。</p><h2 id="并发下诡异的HashMap"><a href="#并发下诡异的HashMap" class="headerlink" title="并发下诡异的HashMap"></a>并发下诡异的HashMap</h2><p>HashMap同样不是线程安全的，当你使用多线程访问HashMap时也会遇到意想不到的错误：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HashMapMultiThread</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> Map&lt;String, String&gt;map = <span class="keyword">new</span> HashMap&lt;String, String&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">AddThread</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> start = <span class="number">0</span>;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">AddThread</span><span class="params">(<span class="keyword">int</span> start)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.start = start;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = start; i &lt; <span class="number">100000</span>; i += <span class="number">2</span>) &#123;</span><br><span class="line">                map.put(Integer.toString(i), Integer.toBinaryString(i));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException</span>&#123;</span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> HashMapMultiThread.AddThread(<span class="number">0</span>));</span><br><span class="line">        Thread t2 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> HashMapMultiThread.AddThread(<span class="number">1</span>));</span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">        t1.join();t2.join();</span><br><span class="line">        System.out.println(map.size());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果运行正常会打印100000，但是你可能得到以下两种意外结果：</p><ol><li><p>程序正常结束，但得到一个比100000小的数字，比如95868。</p></li><li><p><del>程序永远无法结束，这在JDK8中已经不存在，详细原因可以查看此<a href="https://coolshell.cn/articles/9606.html" target="_blank" rel="noopener">传送门</a></del>。</p></li><li><p>抛异常：</p><p><img src="https://ws1.sinaimg.cn/large/73d640f7gy1ftl9vva3yaj20zs0aft9n.jpg" alt=""></p></li></ol><p>异常的大概意思HashMap.Node与HashMap.TreeNode进行了异常映射。</p><p><a href="https://stackoverflow.com/questions/29967401/strange-hashmap-exception-hashmapnode-cannot-be-cast-to-hashmaptreenode/29971168" target="_blank" rel="noopener">stackoverflow</a>有两个回答解释得比较好：</p><p>As you can see Java 8’s HashMap has a method called <code>treeify</code> to improve internal storage. Since you’re not using the map in a threadsafe way (as the others already commented) one thread relies on an entry being of class <code>TreeNode</code> while the other most probably changed the same reference to an entry which was of class <code>Node</code> (both extend <code>Map.Entry</code>). – <a href="https://stackoverflow.com/users/637853/thomas" target="_blank" rel="noopener">Thomas</a></p><p>I also found the same exception with your code. I added a <code>synchronized</code> modifier on the <code>putEntriesToMap()</code> method, and the error seemed to stop occurring. The problem is that both threads are modifying the same map at once. There is an object that must be converted to put the entry in. However, the second thread is dealing with a mutated object, which throws a <code>ClassCastException</code>. So, make sure that no two threads are accessing the same map at once. The <code>synchronized</code> modifier stops all other threads from doing anything with the class/instance if another thread is doing the same. Synchronized static methods synchronize the class itself, whereas synchronized non-static methods only synchronize the instance of the class.–<a href="https://stackoverflow.com/users/8200485/hyperneutrino" target="_blank" rel="noopener">HyperNeutrino</a></p><p>JDK7中HashMap采用的是位桶+链表的方式。而JDK8中采用的是位桶+链表/红黑树的方式，当某个位桶的链表的长度超过8的时候，这个链表就将转换成红黑树。链表转换红黑树在treeify方法里实现。Node和TreeNode都继承自Map.Entry这个内部接口，所以若map在线程非安全的情况下进行操作，一个线程依赖TreeNode这个类的接口进行存储，而另一个线程又在相同的位置采用Node类的接口进行修改，则会产生如上错误。</p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ol><li><a href="https://coolshell.cn/articles/9606.html" target="_blank" rel="noopener">https://coolshell.cn/articles/9606.html</a></li><li><a href="https://stackoverflow.com/questions/29967401/strange-hashmap-exception-hashmapnode-cannot-be-cast-to-hashmaptreenode/29971168" target="_blank" rel="noopener">https://stackoverflow.com/questions/29967401/strange-hashmap-exception-hashmapnode-cannot-be-cast-to-hashmaptreenode/29971168</a></li><li><a href="https://www.jianshu.com/p/4177dc15d658" target="_blank" rel="noopener">https://www.jianshu.com/p/4177dc15d658</a></li><li><a href="https://www.zhihu.com/question/26595480" target="_blank" rel="noopener">https://www.zhihu.com/question/26595480</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;什么是线程安全&quot;&gt;&lt;a href=&quot;#什么是线程安全&quot; class=&quot;headerlink&quot; title=&quot;什么是线程安全&quot;&gt;&lt;/a&gt;什么是线程安全&lt;/h2&gt;&lt;h3 id=&quot;正确性&quot;&gt;&lt;a href=&quot;#正确性&quot; class=&quot;headerlink&quot; title=&quot;正确性&quot;&gt;&lt;/a&gt;正确性&lt;/h3&gt;&lt;blockquote&gt;&lt;p&gt;当多个线程访问某个类时，不管运行时环境采用何种调度方式或者这些线程将如何交替执行，并且在主调代码中不需要任何额外的同步或协同，这个类都能表现出正确的行为，那么就称这个类是线程安全的。&lt;/p&gt;&lt;/blockquote&gt;&lt;h3 id=&quot;同步&quot;&gt;&lt;a href=&quot;#同步&quot; class=&quot;headerlink&quot; title=&quot;同步&quot;&gt;&lt;/a&gt;同步&lt;/h3&gt;&lt;blockquote&gt;&lt;p&gt;在线程安全类中封装了必要的同步机制，因此客户端无须进一步采用同步措施。&lt;/p&gt;&lt;/blockquote&gt;
    
    </summary>
    
      <category term="Java" scheme="https://jasonren.top/categories/Java/"/>
    
    
      <category term="并发" scheme="https://jasonren.top/tags/%E5%B9%B6%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>melody sidebar侧栏toc显示问题</title>
    <link href="https://jasonren.top/2017/12/26/hexo-fixed-sidebartoc/"/>
    <id>https://jasonren.top/2017/12/26/hexo-fixed-sidebartoc/</id>
    <published>2017-12-25T16:00:00.000Z</published>
    <updated>2018-11-22T07:51:49.931Z</updated>
    
    <content type="html"><![CDATA[<h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>一时兴起，换了个漂亮点的hexo主题<a href="https://molunerfinn.com/hexo-theme-melody-doc/#/" target="_blank" rel="noopener">melody</a>。</p><p>一波插件及风格化调好之后，发现sidebar出现了问题。如下图所示：</p><p><img src="https://ws1.sinaimg.cn/large/73d640f7gy1ftl9vvr734j20a109xmx4.jpg" alt="sidebar目录"></p><a id="more"></a><br><p>就是锚点和标题始终不在同一行，用chrome开发者工具发现渲染后sidebar被解析为了如下内容：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">"toc-item toc-level-2"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">a</span> <span class="attr">class</span>=<span class="string">"toc-link"</span> <span class="attr">href</span>=<span class="string">"#线程的生命周期"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">"toc-number"</span>&gt;</span>1.<span class="tag">&lt;/<span class="name">span</span>&gt;</span> <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">"toc-text"</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"#线程的生命周期"</span> <span class="attr">class</span>=<span class="string">"headerlink"</span> <span class="attr">title</span>=<span class="string">"线程的生命周期"</span>&gt;</span><span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">  线程的生命周期</span><br><span class="line"><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br></pre></td></tr></table></figure><p>显然这个解析是有问题的。</p><h2 id="问题解决"><a href="#问题解决" class="headerlink" title="问题解决"></a>问题解决</h2><p>起初怀疑是跨标题级别的问题，于是把不符合规则的博文都格式化了一遍，发现问题依旧没有解决。后来发现是markdown渲染插件的问题，需要安装<code>hexo-renderer-markdown-it</code>这个<a href="https://github.com/hexojs/hexo-renderer-markdown-it" target="_blank" rel="noopener">插件</a>，步骤如下：</p><p>先卸载已有的默认渲染插件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> npm un hexo-renderer-marked --save</span></span><br></pre></td></tr></table></figure><p>再安装新的插件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> npm i hexo-renderer-markdown-it --save</span></span><br></pre></td></tr></table></figure><p>以为问题解决了，但是点击到小标题上会出现undefined报错，并且点击无法跳转。</p><p><img src="https://ws1.sinaimg.cn/large/73d640f7gy1ftl9vvqa8zj20a80an3yj.jpg" alt="服务器端文章目录只能显示一级标题，并且无法点击跳转"></p><p>最后google到解决方案如下，只需要在node_modules\hexo-render-markdown-it\lib\renderer.js 添加一行代码，让我们新安装的插件work起来即可：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">'use strict'</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = <span class="function"><span class="keyword">function</span> (<span class="params">data, options</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> MdIt = <span class="built_in">require</span>(<span class="string">'markdown-it'</span>);</span><br><span class="line">  <span class="keyword">var</span> cfg = <span class="keyword">this</span>.config.markdown;</span><br><span class="line">  <span class="keyword">var</span> opt = (cfg) ? cfg : <span class="string">'default'</span>;</span><br><span class="line">  <span class="keyword">var</span> parser = (opt === <span class="string">'default'</span> || opt === <span class="string">'commonmark'</span> || opt === <span class="string">'zero'</span>) ?</span><br><span class="line">    <span class="keyword">new</span> MdIt(opt) :</span><br><span class="line">    <span class="keyword">new</span> MdIt(opt.render);</span><br><span class="line"></span><br><span class="line">  parser.use(<span class="built_in">require</span>(<span class="string">'markdown-it-named-headings'</span>)) <span class="comment">//new add</span></span><br><span class="line"></span><br><span class="line"> <span class="keyword">if</span> (opt.plugins) &#123;</span><br><span class="line">    parser = opt.plugins.reduce(<span class="function"><span class="keyword">function</span> (<span class="params">parser, pugs</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> parser.use(<span class="built_in">require</span>(pugs));</span><br><span class="line">    &#125;, parser);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (opt.anchors) &#123;</span><br><span class="line">    parser = parser.use(<span class="built_in">require</span>(<span class="string">'./anchors'</span>), opt.anchors);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> parser.render(data.text);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>直接采用hexo-render-markdown-it这个解析插件还有问题，若你正在使用<!-- more -->实现阅读全文功能，它会直接对<code>&lt;</code> 和 <code>&gt;</code>编码导致阅读全文功能不能正常work，有个小哥用escape嵌套解决了这个问题：</p><p><img src="https://ws1.sinaimg.cn/large/73d640f7gy1ftl9vvb2wvj20qq0eq75i.jpg" alt="escape块"></p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ol><li><a href="https://github.com/iissnan/hexo-theme-next/issues/974" target="_blank" rel="noopener">https://github.com/iissnan/hexo-theme-next/issues/974</a></li><li><a href="https://github.com/hexojs/hexo-renderer-markdown-it/wiki/Getting-Started" target="_blank" rel="noopener">https://github.com/hexojs/hexo-renderer-markdown-it/wiki/Getting-Started</a></li><li><a href="https://github.com/hexojs/hexo-renderer-markdown-it/issues/40" target="_blank" rel="noopener">https://github.com/hexojs/hexo-renderer-markdown-it/issues/40</a></li><li><a href="https://github.com/hexojs/hexo/issues/2316#issuecomment-277344775" target="_blank" rel="noopener">https://github.com/hexojs/hexo/issues/2316#issuecomment-277344775</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;问题描述&quot;&gt;&lt;a href=&quot;#问题描述&quot; class=&quot;headerlink&quot; title=&quot;问题描述&quot;&gt;&lt;/a&gt;问题描述&lt;/h2&gt;&lt;p&gt;一时兴起，换了个漂亮点的hexo主题&lt;a href=&quot;https://molunerfinn.com/hexo-theme-melody-doc/#/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;melody&lt;/a&gt;。&lt;/p&gt;&lt;p&gt;一波插件及风格化调好之后，发现sidebar出现了问题。如下图所示：&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;https://ws1.sinaimg.cn/large/73d640f7gy1ftl9vvr734j20a109xmx4.jpg&quot; alt=&quot;sidebar目录&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="前端" scheme="https://jasonren.top/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="hexo" scheme="https://jasonren.top/tags/hexo/"/>
    
  </entry>
  
  <entry>
    <title>Java并发基础(二)</title>
    <link href="https://jasonren.top/2017/12/20/java%E5%B9%B6%E5%8F%91%E5%9F%BA%E7%A1%802/"/>
    <id>https://jasonren.top/2017/12/20/java并发基础2/</id>
    <published>2017-12-19T16:00:00.000Z</published>
    <updated>2018-11-22T07:51:49.932Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>上节主要介绍了线程的生命周期和一些基本操作，这节主要描述一些多线程常用的API。</p><h2 id="一些重要的API"><a href="#一些重要的API" class="headerlink" title="一些重要的API"></a>一些重要的API</h2><h3 id="wait和notify"><a href="#wait和notify" class="headerlink" title="wait和notify"></a>wait和notify</h3><p>下图演示了notify()和wait()是如何工作的：</p><p><img src="https://ws1.sinaimg.cn/large/73d640f7gy1ftl9vw9e61j20kk0etmxo.jpg" alt="notify()和wait()"><br><a id="more"></a><br>这两个方法属于<code>Object</code>类，可以被任何对象调用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">wait</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">notify</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure><p>其次，Object.wait()不是随便可以调用的，它必须含在对应的<code>synchronized</code>语句中，因为无论是wait()和notify()都需要首先获得目标对象的一个监视器，其工作细节如下：</p><p><img src="https://ws1.sinaimg.cn/large/73d640f7gy1ftla8l9px9j20e30a33yn.jpg" alt="wait()和notify()工作细节"></p><p>从这里就可以更好地区别Object.wait()和Thread.sleep()，前者会释放目标对象的锁，而后者不会释放任何资源。</p><h3 id="查看线程信息"><a href="#查看线程信息" class="headerlink" title="查看线程信息"></a>查看线程信息</h3><p>需要jps(JVM Process Status Tool)虚拟机进程状况工具和jstack堆栈跟踪工具进行配合。其中jps可以显示当前系统中所有的Java进程，而jstack可以打印给定Java进程的内部进程及其堆栈。</p><p>先运行jps获得LVMID(Local Virtual Machine Identifier, LVMID)，其对于本地虚拟机来说与PID是一致的。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> jps</span></span><br><span class="line">13552 Jps</span><br><span class="line">8152 BadSuspend</span><br><span class="line">5964</span><br><span class="line">9916 Launcher</span><br></pre></td></tr></table></figure><p>由上一部我们获得了进入临界区的程序的PID号为8152，接下来我们可以打印相应的线程信息：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> jstack -l 8152</span></span><br><span class="line">Full thread dump Java HotSpot(TM) 64-Bit Server VM (25.121-b13 mixed mode):</span><br><span class="line"></span><br><span class="line">"t2" #13 prio=5 os_prio=0 tid=0x0000000019cd3000 nid=0x2934 runnable [0x1ab5f000]</span><br><span class="line">   java.lang.Thread.State: RUNNABLE</span><br><span class="line">        at java.lang.Thread.suspend0(Native Method)</span><br><span class="line">        at java.lang.Thread.suspend(Thread.java:1029)</span><br><span class="line">        at highConcurrency.BadSuspend$ChangeObjectThread.run(BadSuspend.java:18)</span><br><span class="line">        - locked &lt;0x00000000d5f877a8&gt; (a java.lang.Object)</span><br></pre></td></tr></table></figure><h3 id="join和yield"><a href="#join和yield" class="headerlink" title="join和yield"></a>join和yield</h3><p>如果一个线程的输入非常依赖于另外一个或多个线程的输出，那么此线程必须等待依赖线程执行完毕，才能继续执行。JDK提供join()来实现此功能：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">join</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">join</span><span class="params">(<span class="keyword">long</span> millis)</span> <span class="keyword">throws</span> InterruptedException</span></span><br></pre></td></tr></table></figure><p>第一个join()表示可能无限等待，它会一直阻塞当前线程直到目标线程执行完毕；第二个方法给出了最大等待时间，超过这个时间就算目标线程还未执行完，当前线程也会停止等待而继续往下执行。</p><p>另外一个可以经常使用的方法是Thread.yield()：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">yield</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure><p>如果你觉得一个线程优先级较低，或是它已经完成了一些重要的工作，不希望其占用太多的CPU资源，此时你可以适当地调用Thread.yield()给予其它线程更多的工作机会。但当前线程就算让出CPU后，还是会进行CPU资源的竞争，是否能够再次被分配到就不好说了！</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;上节主要介绍了线程的生命周期和一些基本操作，这节主要描述一些多线程常用的API。&lt;/p&gt;&lt;h2 id=&quot;一些重要的API&quot;&gt;&lt;a href=&quot;#一些重要的API&quot; class=&quot;headerlink&quot; title=&quot;一些重要的API&quot;&gt;&lt;/a&gt;一些重要的API&lt;/h2&gt;&lt;h3 id=&quot;wait和notify&quot;&gt;&lt;a href=&quot;#wait和notify&quot; class=&quot;headerlink&quot; title=&quot;wait和notify&quot;&gt;&lt;/a&gt;wait和notify&lt;/h3&gt;&lt;p&gt;下图演示了notify()和wait()是如何工作的：&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;https://ws1.sinaimg.cn/large/73d640f7gy1ftl9vw9e61j20kk0etmxo.jpg&quot; alt=&quot;notify()和wait()&quot;&gt;&lt;br&gt;
    
    </summary>
    
      <category term="Java" scheme="https://jasonren.top/categories/Java/"/>
    
    
      <category term="并发" scheme="https://jasonren.top/tags/%E5%B9%B6%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>Java并发基础(一)</title>
    <link href="https://jasonren.top/2017/12/19/java%E5%B9%B6%E5%8F%91%E5%9F%BA%E7%A1%801/"/>
    <id>https://jasonren.top/2017/12/19/java并发基础1/</id>
    <published>2017-12-18T16:00:00.000Z</published>
    <updated>2018-11-22T09:32:53.076Z</updated>
    
    <content type="html"><![CDATA[<h2 id="线程的生命周期"><a href="#线程的生命周期" class="headerlink" title="线程的生命周期"></a>线程的生命周期</h2><p>在介绍线程前，有必要先介绍一下进程（Process），进程是计算机中的程序关于某数据集合上的一次运行活动，是系统进行资源分配和调度的基本单位，是程序的基本执行实体，可认为是线程的容器。</p><p><img src="https://ws1.sinaimg.cn/large/73d640f7gy1ftl9ury7vsj20ph0bb0ua.jpg" alt="线程状态图"><br><a id="more"></a></p><p>线程的所有状态均在Thread中的State枚举中定义：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> State&#123;</span><br><span class="line">NEW,</span><br><span class="line">  RUNNABLE,</span><br><span class="line">  BLOCKED,</span><br><span class="line">  WAITING,</span><br><span class="line">  TIMED_WAITING,</span><br><span class="line">  TERMINATED;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>说明：</p><ul><li>NEW状态表示创建一个新的线程对象，该线程处于创建状态，还未开始执行。</li><li>等到执行线程的<code>start()</code>方法，为线程分配必须的系统资源，安排其运行。并调用<strong>线程体</strong>—<code>run()</code>调用时，才表示线程开始执行。</li><li>当线程执行时，处于RUNNABLE可运行状态，这一状态并不是运行中状态（RUNNING），因为线程也许实际上并未真正运行。</li><li>当线程在执行过程中遇到了<code>synchronized</code>同步块，就会进入BLOCKED阻塞状态，这时线程就会暂停执行，直到获得请求的锁。</li><li>WAITING和TIMED_WAITING都表示等待状态，它们的区别是WAITING会进入一个无时间限制的等待，TIMED_WAITING会进入一个有时限的等待。</li><li>从NEW状态出发后，线程不能再回到NEW状态，同理，处于TERMINATED的线程也不能再回到RUNNABLE状态。</li></ul><h2 id="线程的基本操作"><a href="#线程的基本操作" class="headerlink" title="线程的基本操作"></a>线程的基本操作</h2><h3 id="新建线程"><a href="#新建线程" class="headerlink" title="新建线程"></a>新建线程</h3><p>新建线程只需要new一个线程对象，并start()起来即可。但执行start方法的同时会调用相应的run()方法，若想让线程做点什么，只需要通过以下匿名内部类的方式重写run()方法即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Thead t1 = <span class="keyword">new</span> Thread()&#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">   System.out.println(<span class="string">"I am jason!"</span>); </span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">t1.start();</span><br></pre></td></tr></table></figure><p>但考虑当Java是单继承，这时候往往通过接口的方式来缓解尴尬，其中Runnable接口为实现了run()方法的单方法接口。</p><p>为配合工作，Thread类定义了一个非常重要的构造方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Thread</span><span class="params">(Runnable target)</span></span></span><br></pre></td></tr></table></figure><p>它传入一个Runnable接口的实例，在start()方法调用时，新的线程就会执行<code>Runnable.run()</code>方法。默认的Thread.run()就是直接调用内部的Runnable接口。因此使用Runnable接口告诉线程该做什么，更为合理。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CreateThread</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> CreateThread());</span><br><span class="line">        t1.start();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"I am jason!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="终止线程"><a href="#终止线程" class="headerlink" title="终止线程"></a>终止线程</h3><p>对于一些常驻系统的后台线程，我们有时候可能需要手动关闭。Thread提供了一个暴力方法stop()来暴力终止线程，由于其过于暴力，可能强行把执行到一半的线程终止，引起数据不一致的问题，故JDK在不远的将来可能将此方法废弃。</p><p>下图就是一个stop()方法导致终止线程导致数据不一致的例子：</p><p><img src="https://ws1.sinaimg.cn/large/73d640f7gy1ftl9w8my97j20cn0b73yp.jpg" alt="终止线程导致数据不一致"></p><p>上述方法过于暴力。故一般自定义一个stopMe方法操作标志位stopme，然后由标志位指示当前线程是否需要退出。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StopThreadsafe</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> User u = <span class="keyword">new</span> User();</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span></span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line">        <span class="keyword">private</span> String name;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">User</span><span class="params">()</span></span>&#123;</span><br><span class="line">            id = <span class="number">0</span>;</span><br><span class="line">            name = <span class="string">"0"</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">setId</span><span class="params">(<span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">            id = v;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String u)</span></span>&#123;</span><br><span class="line">            name = u;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">getId</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.id;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">private</span> String <span class="title">getName</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.name;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"User [id="</span> + id + <span class="string">", name = "</span> + name + <span class="string">"]"</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ChangeObjectThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">        <span class="keyword">volatile</span> <span class="keyword">boolean</span> stopme = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">stopMe</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            stopme = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span> (stopme)&#123;</span><br><span class="line">                    System.out.println(<span class="string">"exit by stop me"</span>);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">synchronized</span> (u)&#123;</span><br><span class="line">                    <span class="keyword">int</span> v = (<span class="keyword">int</span>)(System.currentTimeMillis()/<span class="number">1000</span>);</span><br><span class="line">                    u.setId(v);                 </span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        Thread.sleep(<span class="number">100</span>);</span><br><span class="line">                    &#125;<span class="keyword">catch</span> (InterruptedException e)&#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                    u.setName(String.valueOf(v));</span><br><span class="line">                &#125;</span><br><span class="line">                Thread.yield();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ReadObjectThread</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line">                <span class="keyword">synchronized</span> (u)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(u.getId() != Integer.parseInt(u.getName()))&#123;</span><br><span class="line">                        System.out.println(u.toString());</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                Thread.yield();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException</span>&#123;</span><br><span class="line">        <span class="keyword">new</span> ReadObjectThread().start();</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line">            ChangeObjectThread t = <span class="keyword">new</span> ChangeObjectThread();</span><br><span class="line">            t.start();</span><br><span class="line">            Thread.sleep(<span class="number">150</span>);</span><br><span class="line">            t.stopMe();</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="线程中断"><a href="#线程中断" class="headerlink" title="线程中断"></a>线程中断</h3><p>相比终止线程，线程中断不会使线程立即退出，而是给线程发一个通知，至于目标线程接到后如何处理完全由目标线程自行决定。</p><p>线程中断有三种方法，注意区分：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> Thread.interrupt()                  <span class="comment">//通知目标线程中断，置上中断标志位</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">boolean</span> Thread.isInterrupted()           <span class="comment">//检查中断标志位，判断是否被中断</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> Thread.interrupted()    <span class="comment">//判断当前线程中断状态，并清除当前中断状态</span></span><br></pre></td></tr></table></figure><p>中断通常需要加上自己的中断处理逻辑，若不加处理逻辑，则即使某线程被置上了中断状态，但是这个中断不会发生任何作用。下面这段代码表明了常用的中断处理逻辑：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException</span>&#123;</span><br><span class="line">    Thread t1 = <span class="keyword">new</span> Thread()&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(Thread.currentThread().isInterrupted())&#123;</span><br><span class="line">                    System.out.println(<span class="string">"Interruted!"</span>);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">                &#125;<span class="keyword">catch</span> (InterruptedException e)&#123;</span><br><span class="line">                    System.out.println(<span class="string">"Interruted When Sleep"</span>);</span><br><span class="line">                    <span class="comment">//设置中断状态</span></span><br><span class="line">                    Thread.currentThread().interrupt();</span><br><span class="line">                &#125;</span><br><span class="line">                Thread.yield();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    t1.start();</span><br><span class="line">    Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">    t1.interrupt();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意：假如第13行不执行interrupt()再次中断自己，置上中断标志位，则下次循环开始就无法捕获由于Thread.sleep()方法中断并清楚中断标志位这一动作。</p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ol><li><a href="http://blog.csdn.net/sinat_36246371/article/details/53005313" target="_blank" rel="noopener">http://blog.csdn.net/sinat_36246371/article/details/53005313</a></li><li><a href="http://www.cnblogs.com/skywang12345/p/3479024.html" target="_blank" rel="noopener">http://www.cnblogs.com/skywang12345/p/3479024.html</a></li><li><a href="http://ibruce.info/2013/12/19/how-to-stop-a-java-thread/" target="_blank" rel="noopener">http://ibruce.info/2013/12/19/how-to-stop-a-java-thread/</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;线程的生命周期&quot;&gt;&lt;a href=&quot;#线程的生命周期&quot; class=&quot;headerlink&quot; title=&quot;线程的生命周期&quot;&gt;&lt;/a&gt;线程的生命周期&lt;/h2&gt;&lt;p&gt;在介绍线程前，有必要先介绍一下进程（Process），进程是计算机中的程序关于某数据集合上的一次运行活动，是系统进行资源分配和调度的基本单位，是程序的基本执行实体，可认为是线程的容器。&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;https://ws1.sinaimg.cn/large/73d640f7gy1ftl9ury7vsj20ph0bb0ua.jpg&quot; alt=&quot;线程状态图&quot;&gt;&lt;br&gt;
    
    </summary>
    
      <category term="Java" scheme="https://jasonren.top/categories/Java/"/>
    
    
      <category term="并发" scheme="https://jasonren.top/tags/%E5%B9%B6%E5%8F%91/"/>
    
  </entry>
  
</feed>
