<!DOCTYPE HTML><html lang="zh-Hans"><head><meta name="generator" content="Hexo 3.8.0"><meta charset="UTF-8"><title>并发线程池就这么简单 | JasonRen&#39;s Blog</title><meta name="viewport" content="width=device-width,initial-scale=1,user-scalable=no"><meta name="author" content="JasonRen"><meta name="description" content="池化最核心的思想就是把宝贵的资源放到池子里，每次使用都从里面获取，用完之后又放回池子供其他人使用。线程池的好处：消除了频繁创建和消亡线程的系统资源开销面对过量任务的提交能够平缓地劣化，提高响应速度提高线程的可管理性《Java开发手册》也有这么一条：以下源码为jdk1.8.0_171"><meta name="keywords" content="并发"><meta property="og:type" content="article"><meta property="og:title" content="并发线程池就这么简单"><meta property="og:url" content="https://jasonren.top/2018/05/01/并发线程池/index.html"><meta property="og:site_name" content="JasonRen&#39;s Blog"><meta property="og:description" content="池化最核心的思想就是把宝贵的资源放到池子里，每次使用都从里面获取，用完之后又放回池子供其他人使用。线程池的好处：消除了频繁创建和消亡线程的系统资源开销面对过量任务的提交能够平缓地劣化，提高响应速度提高线程的可管理性《Java开发手册》也有这么一条：以下源码为jdk1.8.0_171"><meta property="og:locale" content="zh-Hans"><meta property="og:image" content="https://ws1.sinaimg.cn/large/73d640f7ly1fty0e8ntslj219a07eq6h.jpg"><meta property="og:image" content="https://ws1.sinaimg.cn/mw690/73d640f7gy1fu08fk9jbnj20s415ydr7.jpg"><meta property="og:image" content="https://ws1.sinaimg.cn/mw690/73d640f7gy1fu08fk2nsoj20w40dwq72.jpg"><meta property="og:image" content="https://ws1.sinaimg.cn/large/73d640f7ly1fty74ibpzmj21cc0z64fk.jpg"><meta property="og:updated_time" content="2018-11-22T07:51:49.930Z"><meta name="twitter:card" content="summary"><meta name="twitter:title" content="并发线程池就这么简单"><meta name="twitter:description" content="池化最核心的思想就是把宝贵的资源放到池子里，每次使用都从里面获取，用完之后又放回池子供其他人使用。线程池的好处：消除了频繁创建和消亡线程的系统资源开销面对过量任务的提交能够平缓地劣化，提高响应速度提高线程的可管理性《Java开发手册》也有这么一条：以下源码为jdk1.8.0_171"><meta name="twitter:image" content="https://ws1.sinaimg.cn/large/73d640f7ly1fty0e8ntslj219a07eq6h.jpg"><link rel="alternative" href="/atom.xml" title="JasonRen&#39;s Blog" type="application/atom+xml"><link rel="icon" href="/img/favicon.ico"><link rel="apple-touch-icon" href="/img/cat.png"><link rel="apple-touch-icon-precomposed" href="/img/cat.png"><link rel="stylesheet" href="/css/style.css"></head></html><body><header><div><div id="imglogo"><a href="/"><img src="/img/cat.png" alt="JasonRen&#39;s Blog" title="JasonRen&#39;s Blog"></a></div><div id="textlogo"><h1 class="site-name"><a href="/" title="JasonRen&#39;s Blog">JasonRen&#39;s Blog</a></h1><h2 class="blog-motto">Hello World!</h2></div><div class="navbar"><a class="navbutton navmobile" href="#" title="Menu"></a></div><nav class="animated"><ul><ul><li><a href="/">主页|Home</a></li><li><a href="/archives">归档|Archives</a></li><li><a href="/about">关于|About</a></li><li><form class="search" action="//google.com/search" method="get" accept-charset="utf-8"><label>Search</label> <input type="search" id="search" name="q" autocomplete="off" maxlength="20" placeholder="Search"> <input type="hidden" name="q" value="site:jasonren.top"></form></li></ul></ul></nav></div></header><div id="container"><div id="main" class="post" itemscope itemprop="blogPost"><article itemprop="articleBody"><header class="article-info clearfix"><h1 itemprop="name"><a href="/2018/05/01/并发线程池/" title="并发线程池就这么简单" itemprop="url">并发线程池就这么简单</a></h1><p class="article-author">By <a href="/about" title="JasonRen" target="_blank" itemprop="author">JasonRen</a></p><p class="article-time"><time datetime="2018-04-30T16:00:00.000Z" itemprop="datePublished">Published 2018-05-01</time></p></header><div class="article-content"><div id="toc" class="toc-article"><strong class="toc-title">Contents</strong><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#线程池原理"><span class="toc-number">1.</span> <span class="toc-text">线程池原理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#线程池是如何创建的"><span class="toc-number">1.1.</span> <span class="toc-text">线程池是如何创建的</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#线程池的状态"><span class="toc-number">2.</span> <span class="toc-text">线程池的状态</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#新任务到达，线程池如何处理"><span class="toc-number">3.</span> <span class="toc-text">新任务到达，线程池如何处理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#创建线程池的addWorker-方法"><span class="toc-number">4.</span> <span class="toc-text">创建线程池的addWorker()方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#线程池最核心的方法runWorker-方法"><span class="toc-number">5.</span> <span class="toc-text">线程池最核心的方法runWorker()方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#线程池关闭"><span class="toc-number">6.</span> <span class="toc-text">线程池关闭</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#线程池的种类"><span class="toc-number">7.</span> <span class="toc-text">线程池的种类</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#newFixedThreadPool"><span class="toc-number">7.1.</span> <span class="toc-text">newFixedThreadPool</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#newCachedThreadPool"><span class="toc-number">7.2.</span> <span class="toc-text">newCachedThreadPool</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#newSingleThreadExecutor"><span class="toc-number">7.3.</span> <span class="toc-text">newSingleThreadExecutor</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#SpringBoot中的线程池"><span class="toc-number">8.</span> <span class="toc-text">SpringBoot中的线程池</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#参考链接"><span class="toc-number">9.</span> <span class="toc-text">参考链接</span></a></li></ol></div><blockquote><p>池化最核心的思想就是把宝贵的资源放到池子里，每次使用都从里面获取，用完之后又放回池子供其他人使用。</p></blockquote><p>线程池的好处：</p><ol><li>消除了频繁创建和消亡线程的系统资源开销</li><li>面对过量任务的提交能够平缓地劣化，提高响应速度</li><li>提高线程的可管理性</li></ol><p>《Java开发手册》也有这么一条：</p><p><img src="https://ws1.sinaimg.cn/large/73d640f7ly1fty0e8ntslj219a07eq6h.jpg" alt=""></p><blockquote><p>以下源码为jdk1.8.0_171</p></blockquote><a id="more"></a><h2 id="线程池原理"><a href="#线程池原理" class="headerlink" title="线程池原理"></a>线程池原理</h2><p>JDK主要提供了Executor框架来使用线程池，它是线程池的基础，提供了一种将任务提交与任务执行分开的解耦机制。</p><h3 id="线程池是如何创建的"><a href="#线程池是如何创建的" class="headerlink" title="线程池是如何创建的"></a>线程池是如何创建的</h3><p>先来看看ThreadPoolExecutor的构造函数<br><img src="https://ws1.sinaimg.cn/mw690/73d640f7gy1fu08fk9jbnj20s415ydr7.jpg" alt=""></p><p>创建一个线程一般需要输入几个参数：</p><ul><li><code>corePoolSize</code>：线程池的基本大小，当提交一个任务到线程池，若需要执行的任务没有超过线程池的基本大小，即使当前有其他空闲的基本线程，就创建一个新的线程；</li><li><code>maximumPoolSize</code>：线程池允许的最大线程数，若使用了无界队列此参数就没什么效果；</li><li><code>keepAliveTime</code>：线程活动保持时间，即线程池的工作线程空闲后保持存活的时间；</li><li><code>unit</code>：线程活动保持时间的单位；</li><li><code>workQueue</code>：任务队列，用于保存等待执行的任务的阻塞队列；</li><li><code>threadFactory</code>：用于设置创建线程的工厂，可通过它给创建出来的线程设置更有意义的名字，默认的DefaultThreadFactory名字为<code>namePrefix = &quot;pool-&quot; + poolNumber.getAndIncrement() +&quot;-thread-&quot; + threadNumber.getAndIncrement()</code>；</li><li><code>handler</code>：饱和策略，当任务队列和线程池都满了的时候，必须采取一种策略处理新的任务，默认为AbortPolicy，无法处理新任务时抛出异常<ul><li>AbortPolicy：直接拒绝所提交的任务，抛出RejectedExecutionException异常</li><li>CallerRunsPolicy：只用调用者所在线程来执行任务</li><li>DiscardPolicy：不处理直接丢弃掉任务</li><li>DiscardOldestPolicy：丢弃掉阻塞队列中存放时间的任务并重试execute()</li></ul></li></ul><h2 id="线程池的状态"><a href="#线程池的状态" class="headerlink" title="线程池的状态"></a>线程池的状态</h2><p>定义一个AtomicInteger类型的ctl来标识线程池的状态，高三位表示「线程池状态」，低三位表示「线程池中的任务数量」。</p><p>线程池状态标识意义：</p><ul><li>RUNNING （111）：能接收新任务并且处理在队列中的任务</li><li>SHUTDOWN （000）：不接收新任务，只能处理已经提交的任务</li><li>STOP （001）：不接收新任务，也不处理已提交的任务，并中断正在处理的任务</li><li>TIDYING （010）：当所有的任务已终止，ctl记录的“任务数量”为0，线程池会变为TIDYING状态，且执行钩子函数terminated()，若想在线程池变为此状态时添加处理逻辑，可重载terminated()方法</li><li>TERMINATED（011）：terminated()方法执行完毕，线程池彻底终止</li></ul><p>状态转移如下图：</p><p><img src="https://ws1.sinaimg.cn/mw690/73d640f7gy1fu08fk2nsoj20w40dwq72.jpg" alt=""></p><h2 id="新任务到达，线程池如何处理"><a href="#新任务到达，线程池如何处理" class="headerlink" title="新任务到达，线程池如何处理"></a>新任务到达，线程池如何处理</h2><p>当提交一个新任务到线程池时，会经历如下步骤：</p><ol><li>如果当前运行的线程少于corePoolSize，则会创建新的线程来执行新的任务；</li><li>如果运行的线程个数等于或者大于corePoolSize，则会将提交的任务存放到阻塞队列workQueue中；</li><li>如果当前workQueue队列已满的话，则会创建新的线程来执行任务（执行这一步需要获取全局锁）；</li><li>如果线程个数已经超过了maximumPoolSize，则会使用饱和策略RejectedExecutionHandler来进行处理。</li></ol><p>提交任务的核心函数为<code>execute()</code>，其处理逻辑为：<br><img src="https://ws1.sinaimg.cn/large/73d640f7ly1fty74ibpzmj21cc0z64fk.jpg" alt=""></p><p><code>execute()</code>源码为：<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable command)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//如果没有任务，报空指针异常</span></span><br><span class="line">        <span class="keyword">if</span> (command == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">        <span class="comment">//获取当前线程池的状态</span></span><br><span class="line">        <span class="keyword">int</span> c = ctl.get();</span><br><span class="line">        <span class="comment">//如果工作线程数量小于corePoolSize，创建一个新的线程</span></span><br><span class="line">        <span class="keyword">if</span> (workerCountOf(c) &lt; corePoolSize) &#123;</span><br><span class="line">            <span class="comment">//如果添加成功就直接返回</span></span><br><span class="line">            <span class="keyword">if</span> (addWorker(command, <span class="keyword">true</span>))</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            <span class="comment">//否则再次获取活动线程数量</span></span><br><span class="line">            c = ctl.get();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//否则如果当前线程处于运行状态且写入阻塞队列成功，则进行二次检查</span></span><br><span class="line">        <span class="keyword">if</span> (isRunning(c) &amp;&amp; workQueue.offer(command)) &#123;</span><br><span class="line">            <span class="comment">//再次对线程池状态检查，因为上面addWorke()过了并且失败了，所以需要检查</span></span><br><span class="line">            <span class="keyword">int</span> recheck = ctl.get();</span><br><span class="line">            <span class="comment">//如果线程池不是运行状态，就需要从阻塞队列移除任务，同时执行拒绝策略</span></span><br><span class="line">            <span class="keyword">if</span> (! isRunning(recheck) &amp;&amp; remove(command))</span><br><span class="line">                reject(command);</span><br><span class="line">            <span class="comment">//如果当前线程池为空（线程池已关闭），则添加一个null到队列中</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (workerCountOf(recheck) == <span class="number">0</span>)</span><br><span class="line">                <span class="comment">//添加一个空的任务</span></span><br><span class="line">                addWorker(<span class="keyword">null</span>, <span class="keyword">false</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//上述if判断为非运行状态，尝试新建线程，如果失败则执行拒绝策略</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (!addWorker(command, <span class="keyword">false</span>))</span><br><span class="line">            reject(command);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p></p><h2 id="创建线程池的addWorker-方法"><a href="#创建线程池的addWorker-方法" class="headerlink" title="创建线程池的addWorker()方法"></a>创建线程池的addWorker()方法</h2><p>该方法签名为</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">addWorker</span><span class="params">(Runnable firstTask, <span class="keyword">boolean</span> core)</span></span></span><br></pre></td></tr></table></figure><p>第一个参数为<code>Runnable</code>类型，表示线程池中某个新提交的任务，第二参数如果为true，创建<code>core</code>核心线程，如果为false，则创建<code>maximumPoolSize</code>线程，这两类线程的生命周期不同。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">boolean</span> workerStarted = <span class="keyword">false</span>;</span><br><span class="line">      <span class="keyword">boolean</span> workerAdded = <span class="keyword">false</span>;</span><br><span class="line">      Worker w = <span class="keyword">null</span>;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">           <span class="comment">//创建一个Worker对象</span></span><br><span class="line">	     <span class="comment">// 其代理了任务对象，并通过线程工厂创建线程</span></span><br><span class="line">          w = <span class="keyword">new</span> Worker(firstTask);</span><br><span class="line">          <span class="keyword">final</span> Thread t = w.thread;</span><br><span class="line">          <span class="keyword">if</span> (t != <span class="keyword">null</span>) &#123;</span><br><span class="line">              <span class="keyword">final</span> ReentrantLock mainLock = <span class="keyword">this</span>.mainLock;</span><br><span class="line">              mainLock.lock();</span><br><span class="line">              <span class="keyword">try</span> &#123;</span><br><span class="line">                  <span class="comment">// Recheck while holding lock.</span></span><br><span class="line">                  <span class="comment">// Back out on ThreadFactory failure or if</span></span><br><span class="line">                  <span class="comment">// shut down before lock acquired.</span></span><br><span class="line">                  <span class="keyword">int</span> rs = runStateOf(ctl.get());</span><br><span class="line">			<span class="comment">// rs &lt; SHUTDOWN表示是RUNNING状态</span></span><br><span class="line">                  <span class="comment">// 如果rs是RUNNING状态或者rs是SHUTDOWN状态并且firstTask是null，向线程池添加线程</span></span><br><span class="line">                  <span class="comment">// 因为在SHUTDOWN时不会再添加新任务，但还是会执行workQueue中的任务</span></span><br><span class="line">                  <span class="keyword">if</span> (rs &lt; SHUTDOWN ||</span><br><span class="line">                      (rs == SHUTDOWN &amp;&amp; firstTask == <span class="keyword">null</span>)) &#123;</span><br><span class="line">                      <span class="keyword">if</span> (t.isAlive()) <span class="comment">// precheck that t is startable</span></span><br><span class="line">                          <span class="keyword">throw</span> <span class="keyword">new</span> IllegalThreadStateException();</span><br><span class="line">                      <span class="comment">// workers是一个拥有所有线程的HashSet，当获得全局锁才可访问</span></span><br><span class="line">                      workers.add(w);</span><br><span class="line">                      <span class="comment">// largestPoolSize记录着线程池中出现过的最大线程数量</span></span><br><span class="line">                      <span class="keyword">int</span> s = workers.size();</span><br><span class="line">                      <span class="keyword">if</span> (s &gt; largestPoolSize)</span><br><span class="line">                          largestPoolSize = s;</span><br><span class="line">                      workerAdded = <span class="keyword">true</span>;</span><br><span class="line">                  &#125;</span><br><span class="line">              &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                  mainLock.unlock();</span><br><span class="line">              &#125;</span><br><span class="line">              <span class="keyword">if</span> (workerAdded) &#123;</span><br><span class="line">                  <span class="comment">//启动线程</span></span><br><span class="line">                  t.start();</span><br><span class="line">                  workerStarted = <span class="keyword">true</span>;</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">          <span class="keyword">if</span> (! workerStarted)</span><br><span class="line">              addWorkerFailed(w);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> workerStarted;</span><br></pre></td></tr></table></figure><p>Worker类的签名及构造方法签名如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Worker类继承了AQS并实现了Runnable接口</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Worker</span></span></span><br><span class="line"><span class="class">        <span class="keyword">extends</span> <span class="title">AbstractQueuedSynchronizer</span></span></span><br><span class="line"><span class="class">        <span class="keyword">implements</span> <span class="title">Runnable</span></span></span><br><span class="line"><span class="class">// 构造函数</span></span><br><span class="line"><span class="class"><span class="title">Worker</span>(<span class="title">Runnable</span> <span class="title">firstTask</span>) </span>&#123;</span><br><span class="line">            setState(-<span class="number">1</span>); <span class="comment">// inhibit interrupts until runWorker</span></span><br><span class="line">            <span class="keyword">this</span>.firstTask = firstTask;</span><br></pre></td></tr></table></figure><p><strong>注意</strong>：在执行<code>t.start()</code>时，由于<code>this.thread = getThreadFactory().newThread(this)</code>会传入this指针，会间接调用实现了Runnable接口的Worker类的run方法。</p><p>Worker类的run方法实现如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            runWorker(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="线程池最核心的方法runWorker-方法"><a href="#线程池最核心的方法runWorker-方法" class="headerlink" title="线程池最核心的方法runWorker()方法"></a>线程池最核心的方法runWorker()方法</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">runWorker</span><span class="params">(Worker w)</span> </span>&#123;</span><br><span class="line">        Thread wt = Thread.currentThread();</span><br><span class="line">    	<span class="comment">//获取第一个任务</span></span><br><span class="line">        Runnable task = w.firstTask;</span><br><span class="line">        w.firstTask = <span class="keyword">null</span>;</span><br><span class="line">    	<span class="comment">//允许中断</span></span><br><span class="line">        w.unlock(); <span class="comment">// allow interrupts</span></span><br><span class="line">        <span class="keyword">boolean</span> completedAbruptly = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (task != <span class="keyword">null</span> || (task = getTask()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                w.lock();</span><br><span class="line">                <span class="comment">// If pool is stopping, ensure thread is interrupted;</span></span><br><span class="line">                <span class="comment">// if not, ensure thread is not interrupted.  This</span></span><br><span class="line">                <span class="comment">// requires a recheck in second case to deal with</span></span><br><span class="line">                <span class="comment">// shutdownNow race while clearing interrupt</span></span><br><span class="line">                <span class="keyword">if</span> ((runStateAtLeast(ctl.get(), STOP) ||</span><br><span class="line">                     (Thread.interrupted() &amp;&amp;</span><br><span class="line">                      runStateAtLeast(ctl.get(), STOP))) &amp;&amp;</span><br><span class="line">                    !wt.isInterrupted())</span><br><span class="line">                    wt.interrupt();</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    beforeExecute(wt, task);</span><br><span class="line">                    Throwable thrown = <span class="keyword">null</span>;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        task.run();</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (RuntimeException x) &#123;</span><br><span class="line">                        thrown = x; <span class="keyword">throw</span> x;</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (Error x) &#123;</span><br><span class="line">                        thrown = x; <span class="keyword">throw</span> x;</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (Throwable x) &#123;</span><br><span class="line">                        thrown = x; <span class="keyword">throw</span> <span class="keyword">new</span> Error(x);</span><br><span class="line">                    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                        afterExecute(task, thrown);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    task = <span class="keyword">null</span>;</span><br><span class="line">                    w.completedTasks++;</span><br><span class="line">                    w.unlock();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            completedAbruptly = <span class="keyword">false</span>;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            processWorkerExit(w, completedAbruptly);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>总结一下<code>runWorker()</code>的执行过程：</p><ol><li>while循环不断地通过<code>getTask()</code>方法获取任务</li><li><code>getTask()</code>方法从阻塞队列中获取任务</li><li>如果线程池正在停止，要保证当前线程是中断状态；如果不是的话，则要保证当前线程不是中断状态</li><li>调用<code>task.run()</code>执行任务</li><li>如果task为null，则跳出循环，执行<code>processWorkerExit()</code>方法</li><li><code>runWorker()</code>方法执行完成，也即Worker中的<code>run()</code>方法，也即<code>addWorker()</code>中的<code>t.start()</code>方法执行完毕，销毁线程</li></ol><p>注意：</p><p><code>beforeExecute()</code>和<code>afterExecute()</code>在ThreadExecutor中是空的，可以自行扩展功能。</p><h2 id="线程池关闭"><a href="#线程池关闭" class="headerlink" title="线程池关闭"></a>线程池关闭</h2><p>ThreadPoolExecutor提供了<code>shutdown()</code>和<code>shutdownNow()</code>两个方法来关闭线程</p><p><code>shutdown()</code>按照过去任务提交的顺序发起一个有序的关闭，不接受新任务</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">shutdown</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> ReentrantLock mainLock = <span class="keyword">this</span>.mainLock;</span><br><span class="line">        <span class="comment">//加上可重入锁</span></span><br><span class="line">        mainLock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            checkShutdownAccess();</span><br><span class="line">            advanceRunState(SHUTDOWN); <span class="comment">// 设置线程池状态为SHUTDOWN</span></span><br><span class="line">            interruptIdleWorkers();    <span class="comment">//中断空闲线程</span></span><br><span class="line">            onShutdown(); <span class="comment">// hook for ScheduledThreadPoolExecutor</span></span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            mainLock.unlock();         <span class="comment">//释放锁</span></span><br><span class="line">        &#125;</span><br><span class="line">        tryTerminate();                <span class="comment">//将线程池状态设置为TERMINATED</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><code>shutdownNow()</code>也是停止接收新任务，但会中断所有任务，将线程池状态变为TERMINATED</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Runnable&gt; <span class="title">shutdownNow</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        List&lt;Runnable&gt; tasks;</span><br><span class="line">        <span class="keyword">final</span> ReentrantLock mainLock = <span class="keyword">this</span>.mainLock;</span><br><span class="line">        mainLock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            checkShutdownAccess();     </span><br><span class="line">            advanceRunState(STOP);    <span class="comment">//设置线程池状态为STOP</span></span><br><span class="line">            interruptWorkers();       <span class="comment">//中断所有线程</span></span><br><span class="line">            tasks = drainQueue();     <span class="comment">//获取等待的任务列表</span></span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            mainLock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">        tryTerminate();               </span><br><span class="line">        <span class="keyword">return</span> tasks;                 <span class="comment">//返回等待的任务列表</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>区别：</p><ul><li>调用shutdown()后，线程池状态立刻变为SHUTDOWN，而调用shutdownNow()，线程池状态立刻变为STOP；</li><li>shutdown()等待任务执行完才中断线程，而shutdownNow()不等任务执行完就中断了线程。</li></ul><p>Tips: 优雅的线程关闭方式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">5</span>; i++) &#123;</span><br><span class="line">        pool.execute(<span class="keyword">new</span> MyTask());</span><br><span class="line">    &#125;</span><br><span class="line">    pool.shutdown();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!pool.awaitTermination(<span class="number">1</span>, TimeUnit.SECONDS)) &#123;</span><br><span class="line">        LOGGER.info(<span class="string">"线程还在执行呢..."</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">long</span> end = System.currentTimeMillis();</span><br><span class="line">    LOGGER.info(<span class="string">"一共处理了"</span> + (end - start) + <span class="string">"秒"</span>);</span><br></pre></td></tr></table></figure><h2 id="线程池的种类"><a href="#线程池的种类" class="headerlink" title="线程池的种类"></a>线程池的种类</h2><ul><li><strong>固定线程池</strong> ExecutorService service1 = Executors.newFixedThreadPool(5)</li><li><strong>单例线程池</strong> ExecutorService service2 = Executors.newSingleThreadExecutor();</li><li><strong>缓存线程池</strong> ExecutorService service3 = Executors.newCachedThreadPool();</li><li><strong>任务调用线程池</strong> ExecutorService service4 = Executors.newScheduledThreadPool(2);</li></ul><h3 id="newFixedThreadPool"><a href="#newFixedThreadPool" class="headerlink" title="newFixedThreadPool"></a>newFixedThreadPool</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newFixedThreadPool</span><span class="params">(<span class="keyword">int</span> nThreads)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(nThreads, nThreads,</span><br><span class="line">                                      <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                                      <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;());</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>其中corePoolSize等于maximumPoolSize。</p><h3 id="newCachedThreadPool"><a href="#newCachedThreadPool" class="headerlink" title="newCachedThreadPool"></a>newCachedThreadPool</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newCachedThreadPool</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">0</span>, Integer.MAX_VALUE,</span><br><span class="line">                                      <span class="number">60L</span>, TimeUnit.SECONDS,</span><br><span class="line">                                      <span class="keyword">new</span> SynchronousQueue&lt;Runnable&gt;());</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>无限线程池，接收到新任务线程池会毫不犹豫地新开一个线程处理。</p><h3 id="newSingleThreadExecutor"><a href="#newSingleThreadExecutor" class="headerlink" title="newSingleThreadExecutor"></a>newSingleThreadExecutor</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newSingleThreadExecutor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> FinalizableDelegatedExecutorService</span><br><span class="line">            (<span class="keyword">new</span> ThreadPoolExecutor(<span class="number">1</span>, <span class="number">1</span>,</span><br><span class="line">                                    <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                                    <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;()));</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>创建单个worker线程的线程池。</p><h2 id="SpringBoot中的线程池"><a href="#SpringBoot中的线程池" class="headerlink" title="SpringBoot中的线程池"></a>SpringBoot中的线程池</h2><p>需要导入Guava的包</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">dependency&gt;</span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.google.guava<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>guava<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>11.0.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>首先配置线程池：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadPoolConfig</span> </span>&#123;</span><br><span class="line">    <span class="comment">//消费线程队列</span></span><br><span class="line">    <span class="meta">@Bean</span>(value=<span class="string">"consumerQueueThreadPool"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ExecutorService <span class="title">buildConsumerQueueThreadPool</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ThreadFactory namedThreadFactory = <span class="keyword">new</span> ThreadFactoryBuilder()</span><br><span class="line">            .setNameFormat(<span class="string">"consumer-queue-thread-%d"</span>).build();</span><br><span class="line">        ExecutorService pool = <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">5</span>, <span class="number">5</span>, <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">            <span class="keyword">new</span> ArrayBlockingQueue&lt;Runnable&gt;(<span class="number">5</span>), namedThreadFactory, <span class="keyword">new</span> ThreadPoolExecutor.AbortPolicy());</span><br><span class="line">        <span class="keyword">return</span> pool;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>直接使用配置好的消费队列线程池Bean：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Resource</span>(name = <span class="string">"consumerQueueThreadPool"</span>)</span><br><span class="line">    <span class="keyword">private</span> ExecutorService consumerQueueThreadPool;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//消费队列</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            consumerQueueThreadPool.execute(<span class="keyword">new</span> ConsumerQueueThread());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ol><li><a href="http://www.ideabuffer.cn/2017/04/04/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E7%BA%BF%E7%A8%8B%E6%B1%A0%EF%BC%9AThreadPoolExecutor/#addWorker%E6%96%B9%E6%B3%95" target="_blank" rel="noopener">深入理解Java线程池</a></li><li><a href="http://thinkinjava.cn/2018/01/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B9%8B%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E4%BD%BF%E7%94%A8%E5%8F%8A%E6%89%A9%E5%B1%95%E5%92%8C%E4%BC%98%E5%8C%96/" target="_blank" rel="noopener">并发编程之线程池的使用及扩展和优化</a></li><li><a href="http://thinkinjava.cn/2018/01/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B9%8B-%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90-%E7%BA%BF%E7%A8%8B%E6%B1%A0-%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/" target="_blank" rel="noopener">剖析线程池实现原理</a></li><li><a href="https://mp.weixin.qq.com/s/kbOV0mkE_NMypEQK6rZW3A" target="_blank" rel="noopener">如何优雅的使用和理解线程池</a></li><li><a href="https://juejin.im/post/5aeec0106fb9a07ab379574f" target="_blank" rel="noopener">线程池ThreadPoolExecutor实现原理</a></li><li>《阿里巴巴Java开发手册》</li></ol></div><footer class="article-footer clearfix"><div class="article-catetags"><div class="article-categories"><span></span> <a class="article-category-link" href="/categories/Java/">Java</a></div><div class="article-tags"><span></span> <a href="/tags/并发/">并发</a></div></div><div class="article-share" id="share"><div data-url="https://jasonren.top/2018/05/01/并发线程池/" data-title="并发线程池就这么简单 | JasonRen&#39;s Blog" data-tsina="null" class="share clearfix"></div></div></footer></article><nav class="article-nav clearfix"><div class="prev"><a href="/2018/07/21/@Slf4j注解的使用/" title="常用日志系统的配置"><strong>上一篇：</strong><br><span>常用日志系统的配置</span></a></div><div class="next"><a href="/2018/04/16/进程和线程的区别/" title="线程与进程的区别及其通信方式"><strong>下一篇：</strong><br><span>线程与进程的区别及其通信方式</span></a></div></nav><section id="comments" class="comment"><div id="disqus_thread"><noscript>Please enable JavaScript to view the <a href="//disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript></div></section></div><div class="openaside"><a class="navbutton" href="#" title="Show Sidebar"></a></div><div id="toc" class="toc-aside"><strong class="toc-title">Contents</strong><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#线程池原理"><span class="toc-number">1.</span> <span class="toc-text">线程池原理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#线程池是如何创建的"><span class="toc-number">1.1.</span> <span class="toc-text">线程池是如何创建的</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#线程池的状态"><span class="toc-number">2.</span> <span class="toc-text">线程池的状态</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#新任务到达，线程池如何处理"><span class="toc-number">3.</span> <span class="toc-text">新任务到达，线程池如何处理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#创建线程池的addWorker-方法"><span class="toc-number">4.</span> <span class="toc-text">创建线程池的addWorker()方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#线程池最核心的方法runWorker-方法"><span class="toc-number">5.</span> <span class="toc-text">线程池最核心的方法runWorker()方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#线程池关闭"><span class="toc-number">6.</span> <span class="toc-text">线程池关闭</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#线程池的种类"><span class="toc-number">7.</span> <span class="toc-text">线程池的种类</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#newFixedThreadPool"><span class="toc-number">7.1.</span> <span class="toc-text">newFixedThreadPool</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#newCachedThreadPool"><span class="toc-number">7.2.</span> <span class="toc-text">newCachedThreadPool</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#newSingleThreadExecutor"><span class="toc-number">7.3.</span> <span class="toc-text">newSingleThreadExecutor</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#SpringBoot中的线程池"><span class="toc-number">8.</span> <span class="toc-text">SpringBoot中的线程池</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#参考链接"><span class="toc-number">9.</span> <span class="toc-text">参考链接</span></a></li></ol></div><div id="asidepart"><div class="closeaside"><a class="closebutton" href="#" title="Hide Sidebar"></a></div><aside class="clearfix"><div class="github-card"><p class="asidetitle">Github Card</p><div class="github-card" data-github="JasonRen23" data-theme="medium"></div><script type="text/javascript" src="//cdn.jsdelivr.net/github-cards/latest/widget.js"></script></div><div class="categorieslist"><p class="asidetitle">Categories</p><ul><li><a href="/categories/IDE/" title="IDE">IDE<sup>1</sup></a></li><li><a href="/categories/Java/" title="Java">Java<sup>12</sup></a></li><li><a href="/categories/Python/" title="Python">Python<sup>2</sup></a></li><li><a href="/categories/linux/" title="linux">linux<sup>1</sup></a></li><li><a href="/categories/前端/" title="前端">前端<sup>3</sup></a></li><li><a href="/categories/容器云/" title="容器云">容器云<sup>2</sup></a></li><li><a href="/categories/搜索引擎/" title="搜索引擎">搜索引擎<sup>1</sup></a></li><li><a href="/categories/操作系统/" title="操作系统">操作系统<sup>1</sup></a></li><li><a href="/categories/数据库/" title="数据库">数据库<sup>2</sup></a></li><li><a href="/categories/消息队列/" title="消息队列">消息队列<sup>1</sup></a></li><li><a href="/categories/算法/" title="算法">算法<sup>1</sup></a></li><li><a href="/categories/计算机网络/" title="计算机网络">计算机网络<sup>1</sup></a></li></ul></div><div class="tagslist"><p class="asidetitle">Tags</p><ul class="clearfix"><li><a href="/tags/并发/" title="并发">并发<sup>6</sup></a></li><li><a href="/tags/JVM/" title="JVM">JVM<sup>3</sup></a></li><li><a href="/tags/Meteor/" title="Meteor">Meteor<sup>2</sup></a></li><li><a href="/tags/mongodb/" title="mongodb">mongodb<sup>2</sup></a></li><li><a href="/tags/Web技术/" title="Web技术">Web技术<sup>2</sup></a></li><li><a href="/tags/Maven/" title="Maven">Maven<sup>1</sup></a></li><li><a href="/tags/Spring/" title="Spring">Spring<sup>1</sup></a></li><li><a href="/tags/TCP-UDP/" title="TCP/UDP">TCP/UDP<sup>1</sup></a></li><li><a href="/tags/hexo/" title="hexo">hexo<sup>1</sup></a></li><li><a href="/tags/docker/" title="docker">docker<sup>1</sup></a></li><li><a href="/tags/Kafka/" title="Kafka">Kafka<sup>1</sup></a></li><li><a href="/tags/redis/" title="redis">redis<sup>1</sup></a></li><li><a href="/tags/sublime/" title="sublime">sublime<sup>1</sup></a></li><li><a href="/tags/shell脚本/" title="shell脚本">shell脚本<sup>1</sup></a></li><li><a href="/tags/Solr/" title="Solr">Solr<sup>1</sup></a></li><li><a href="/tags/快速排序/" title="快速排序">快速排序<sup>1</sup></a></li><li><a href="/tags/连接池/" title="连接池">连接池<sup>1</sup></a></li><li><a href="/tags/SQL/" title="SQL">SQL<sup>1</sup></a></li><li><a href="/tags/kubernetes/" title="kubernetes">kubernetes<sup>1</sup></a></li><li><a href="/tags/线程与进程/" title="线程与进程">线程与进程<sup>1</sup></a></li></ul></div><div class="rsspart"><a href="/atom.xml" target="_blank" title="rss">RSS</a></div></aside></div></div><footer><div id="footer"><div class="line"><span></span><div class="author"></div></div><section class="info"><p>Hello, I&#39;m JasonRen in Shu.<br>This is my blog, my mind.</p></section><div class="social-font"><a href="https://github.com/JasonRen23" target="_blank" class="icon-github" title="github"></a> <a href="http://www.zhihu.com/people/ren-zhi-cheng-1117" target="_blank" class="icon-zhihu" title="知乎"></a> <a href="mailto:zhicheng_ren@163.com" target="_blank" class="icon-email" title="Email Me"></a></div><p class="copyright">Powered by <a href="http://hexo.io" target="_blank" title="hexo">hexo</a> and Theme by <a href="https://github.com/wuchong/jacman" target="_blank" title="Jacman">Jacman</a> © 2018 <a href="/about" target="_blank" title="JasonRen">JasonRen</a></p></div></footer><script src="/js/jquery-2.0.3.min.js"></script><script src="/js/jquery.imagesloaded.min.js"></script><script src="/js/gallery.js"></script><script src="/js/jquery.qrcode-0.12.0.min.js"></script><script type="text/javascript">$(document).ready(function(){$(".navbar").click(function(){$("header nav").toggleClass("shownav")});var e=0,s=$("#main"),n=$("#asidepart"),a=$(".closeaside"),o=$(".openaside");a.click(function(){n.addClass("fadeOut").css("display","none"),o.css("display","block").addClass("fadeIn"),s.addClass("moveMain")}),o.click(function(){o.css("display","none").removeClass("beforeFadeIn"),n.css("display","block").removeClass("fadeOut").addClass("fadeIn"),s.removeClass("moveMain")}),$(window).scroll(function(){o.css("top",Math.max(80,260-$(this).scrollTop()))}),$(window).resize(function(){"number"==typeof window.innerWidth?e=window.innerWidth:document.documentElement&&document.documentElement.clientWidth&&(e=document.documentElement.clientWidth),1024<=e?$("header nav").removeClass("shownav"):(s.removeClass("moveMain"),n.css("display","block").removeClass("fadeOut"),o.css("display","none"),$("#toc.toc-aside").css("display","none"))})})</script><script type="text/javascript">$(document).ready(function(){var c=$(".article-content>iframe"),n=$(".article-content>embed"),o=($("#toc"),$("#toc.toc-aside")),e=$(".openaside"),i=$(".closeaside");0<c.length&&c.wrap('<div class="video-container" />'),0<n.length&&n.wrap('<div class="video-container" />'),i.click(function(){o.css("display","block").addClass("fadeIn")}),e.click(function(){o.css("display","none")}),$(window).scroll(function(){o.css("top",Math.max(140,320-$(this).scrollTop()))})})</script><script type="text/javascript">$(document).ready(function(){var e=$(".share"),a=e.attr("data-url"),t=encodeURIComponent(a),r=e.attr("data-title"),i=e.attr("data-tsina"),c=(e.attr("description"),['<div class="hoverqrcode clearfix"></div>','<a class="overlay" id="qrcode"></a>','<a href="https://www.facebook.com/sharer.php?u='+t+'" class="article-share-facebook" target="_blank" title="Facebook"></a>','<a href="https://twitter.com/intent/tweet?url='+t+'" class="article-share-twitter" target="_blank" title="Twitter"></a>','<a href="#qrcode" class="article-share-qrcode" title="微信"></a>','<a href="http://widget.renren.com/dialog/share?resourceUrl='+t+"&srcUrl="+t+"&title="+r+'" class="article-share-renren" target="_blank" title="人人"></a>','<a href="http://service.weibo.com/share/share.php?title='+r+"&url="+t+"&ralateUid="+i+'&searchPic=true&style=number" class="article-share-weibo" target="_blank" title="微博"></a>','<span title="Share to"></span>'].join(""));e.append(c),$(".hoverqrcode").hide();var o=0;$(window).resize(function(){$(".hoverqrcode").hide()}),$(".article-share-qrcode").click(function(){!function(){"number"==typeof window.innerWidth?o=window.innerWidth:document.documentElement&&document.documentElement.clientWidth&&(o=document.documentElement.clientWidth);var e=1024<o?200:100,t={render:"image",size:e,fill:"#2ca6cb",text:a,radius:.5,quiet:1},r=$(".article-share-qrcode").position();$(".hoverqrcode").empty().css("width",e).css("height",e).css("left",r.left-e/2+20).css("top",r.top-e-10).qrcode(t)}(),$(".hoverqrcode").toggle()}),$(".article-share-qrcode").hover(function(){},function(){$(".hoverqrcode").hide()})})</script><script type="text/javascript">var disqus_shortname="jasonren";!function(){var e=document.createElement("script");e.type="text/javascript",e.async=!0,e.src="//"+disqus_shortname+".disqus.com/embed.js",(document.getElementsByTagName("head")[0]||document.getElementsByTagName("body")[0]).appendChild(e)}(),function(){var e=document.createElement("script");e.type="text/javascript",e.async=!0,e.src="//"+disqus_shortname+".disqus.com/count.js",(document.getElementsByTagName("head")[0]||document.getElementsByTagName("body")[0]).appendChild(e)}()</script><link rel="stylesheet" href="/fancybox/jquery.fancybox.css" media="screen" type="text/css"><script src="/fancybox/jquery.fancybox.pack.js"></script><script type="text/javascript">$(document).ready(function(){$(".article-content").each(function(a){$(this).find("img").each(function(){if(!$(this).parent().hasClass("fancybox")){var a=this.alt;a&&$(this).after('<span class="caption">'+a+"</span>"),$(this).wrap('<a href="'+this.src+'" title="'+a+'" class="fancybox"></a>')}}),$(this).find(".fancybox").each(function(){$(this).attr("rel","article"+a)})}),$.fancybox&&$(".fancybox").fancybox()})</script><script>var _hmt=_hmt||[];!function(){var e=document.createElement("script");e.src="//hm.baidu.com/hm.js?e6d1f421bbc9962127a50488f9ed37d1";var t=document.getElementsByTagName("script")[0];t.parentNode.insertBefore(e,t)}()</script><div id="totop"><a title="Back to Top"><img src="/img/scrollup.png"></a></div><script src="/js/totop.js"></script></body>